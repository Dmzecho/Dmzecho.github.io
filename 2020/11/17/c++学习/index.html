<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>c++学习 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="c++学习 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="先占一个坑，说说我最爱的《挪威的森林》">
<meta property="og:type" content="article">
<meta property="og:title" content="Norwegian Wood">
<meta property="og:url" content="http:&#x2F;&#x2F;dmzecho.github.io&#x2F;2021&#x2F;01&#x2F;14&#x2F;Norwegian-Wood&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="先占一个坑，说说我最爱的《挪威的森林》">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2021-01-14T14:13:21.729Z">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>Echo</span>
</div>

<div class="icon">
    
        
        <a title="github" href="https://github.com/Dmzecho" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(13)</small></div></li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  site_url"  href="/about">关于</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="13">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="以 in: 开头进行全文搜索" autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color5">math</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a  class=""
           href="/2020/11/19/Hexo%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hexo配置">Hexo配置</span>
            <span class="post-date" title="2020-11-19 22:32:42">2020/11/19</span>
        </a>
        
        <a  class=""
           href="/2020/11/20/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Markdown语法基础">Markdown语法基础</span>
            <span class="post-date" title="2020-11-20 20:22:54">2020/11/20</span>
        </a>
        
        <a  class=""
           href="/2021/01/14/Norwegian-Wood/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Norwegian Wood">Norwegian Wood</span>
            <span class="post-date" title="2021-01-14 22:09:23">2021/01/14</span>
        </a>
        
        <a  class=""
           href="/2020/12/15/Matlab%E5%AD%A6%E4%B9%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Matlab学习">Matlab学习</span>
            <span class="post-date" title="2020-12-15 09:36:27">2020/12/15</span>
        </a>
        
        <a  class=""
           href="/2020/11/10/ROS%E5%AD%A6%E4%B9%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ROS学习">ROS学习</span>
            <span class="post-date" title="2020-11-10 19:42:44">2020/11/10</span>
        </a>
        
        <a  class=""
           href="/2020/11/10/Typora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Typora常用快捷键">Typora常用快捷键</span>
            <span class="post-date" title="2020-11-10 19:42:44">2020/11/10</span>
        </a>
        
        <a  class=""
           href="/2020/11/11/Terminator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Terminator常用快捷键">Terminator常用快捷键</span>
            <span class="post-date" title="2020-11-11 16:18:37">2020/11/11</span>
        </a>
        
        <a  class=""
           href="/2020/11/19/Ubuntu%E5%AD%A6%E4%B9%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Ubuntu学习">Ubuntu学习</span>
            <span class="post-date" title="2020-11-19 22:36:49">2020/11/19</span>
        </a>
        
        <a  class=""
           href="/2020/11/19/Python%E5%AD%A6%E4%B9%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Python学习">Python学习</span>
            <span class="post-date" title="2020-11-19 22:34:16">2020/11/19</span>
        </a>
        
        <a  class=""
           href="/2019/11/02/xx/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="xx">xx</span>
            <span class="post-date" title="2019-11-02 16:43:17">2019/11/02</span>
        </a>
        
        <a  class=""
           href="/2020/11/24/%E5%9B%9B%E5%85%83%E6%95%B0/"
           data-tag="math"
           data-author="" >
            <span class="post-title" title="四元数">四元数</span>
            <span class="post-date" title="2020-11-24 11:50:58">2020/11/24</span>
        </a>
        
        <a  class=""
           href="/2020/11/11/%E5%9B%9B%E6%9C%88%E8%A3%82%E5%B8%9B%20%20%20%E7%AE%80%E5%AA%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="四月裂帛   简媜">四月裂帛   简媜</span>
            <span class="post-date" title="2020-11-11 21:41:44">2020/11/11</span>
        </a>
        
        <a  class=""
           href="/2020/11/17/c++%E5%AD%A6%E4%B9%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="c++学习">c++学习</span>
            <span class="post-date" title="2020-11-17 22:55:06">2020/11/17</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-c++学习" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">c++学习</h1>
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-11-27 22:34:26'>2020-11-17 22:55</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#c-学习——By-Xie"><span class="toc-text">c++学习——By Xie</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VS使用技巧"><span class="toc-text">VS使用技巧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeof关键字"><span class="toc-text">sizeof关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#float-单精度浮点型"><span class="toc-text">float 单精度浮点型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符型"><span class="toc-text">字符型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#转义字符"><span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#布尔型"><span class="toc-text">布尔型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#除法"><span class="toc-text">除法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#取模（取余）运算"><span class="toc-text">取模（取余）运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递增"><span class="toc-text">递增</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#逻辑运算符"><span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三目运算符"><span class="toc-text">三目运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch语句"><span class="toc-text">switch语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rand-生成伪随机整数"><span class="toc-text">rand( )生成伪随机整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#srand-生成真随机数"><span class="toc-text">srand( )生成真随机数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#取出各位上的数字"><span class="toc-text">取出各位上的数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指数函数"><span class="toc-text">指数函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for循环的省略"><span class="toc-text">for循环的省略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#循环嵌套"><span class="toc-text">循环嵌套</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一维数组"><span class="toc-text">一维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除数组中的一个元素"><span class="toc-text">删除数组中的一个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#求数组元素个数"><span class="toc-text">求数组元素个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组前后依次交换元素值"><span class="toc-text">数组前后依次交换元素值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#冒泡排序"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组作为参数传递给函数"><span class="toc-text">数组作为参数传递给函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二维数组名称"><span class="toc-text">二维数组名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二维数组加法"><span class="toc-text">二维数组加法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串数组"><span class="toc-text">字符串数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数的参数传递"><span class="toc-text">函数的参数传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数分文件编写"><span class="toc-text">函数分文件编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针"><span class="toc-text">指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针常量和常量指针"><span class="toc-text">指针常量和常量指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#值传递"><span class="toc-text">值传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#地址传递"><span class="toc-text">地址传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针-冒泡排序（升序）"><span class="toc-text">指针+冒泡排序（升序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结构体"><span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结构体数组"><span class="toc-text">结构体数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结构体指针"><span class="toc-text">结构体指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结构体嵌套"><span class="toc-text">结构体嵌套</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结构体数组嵌套"><span class="toc-text">结构体数组嵌套</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根据某项元素对结构体数组排序"><span class="toc-text">根据某项元素对结构体数组排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无参数调用"><span class="toc-text">无参数调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例——通讯录管理系统"><span class="toc-text">实例——通讯录管理系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量（常量）都在哪"><span class="toc-text">变量（常量）都在哪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆区"><span class="toc-text">堆区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆区创建数组"><span class="toc-text">堆区创建数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用"><span class="toc-text">引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用做函数参数-形参"><span class="toc-text">引用做函数参数(形参)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用做返回值"><span class="toc-text">引用做返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常量引用"><span class="toc-text">常量引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数默认参数"><span class="toc-text">函数默认参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类和结构体"><span class="toc-text">类和结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类成员的访问权限"><span class="toc-text">类成员的访问权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中途退出函数"><span class="toc-text">中途退出函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#成员函数和全局函数"><span class="toc-text">成员函数和全局函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类的嵌套"><span class="toc-text">类的嵌套</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分文件编写"><span class="toc-text">分文件编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数什么时候被调用"><span class="toc-text">构造函数什么时候被调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#析构函数执行堆区数据的释放"><span class="toc-text">析构函数执行堆区数据的释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#浅拷贝的问题"><span class="toc-text">浅拷贝的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#深拷贝解决堆区重复释放的问题"><span class="toc-text">深拷贝解决堆区重复释放的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化列表"><span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态成员变量"><span class="toc-text">静态成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态成员函数"><span class="toc-text">静态成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#只有非静态成员变量属于类的对象上"><span class="toc-text">只有非静态成员变量属于类的对象上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#成员变量和形参名称冲突-this指针"><span class="toc-text">成员变量和形参名称冲突   this指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this返回该对象"><span class="toc-text">*this返回该对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this-指针本质是指针常量"><span class="toc-text">this 指针本质是指针常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#成员函数后加const-常函数"><span class="toc-text">成员函数后加const 常函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造和析构函数上不允许使用类型限定符（如const）"><span class="toc-text">构造和析构函数上不允许使用类型限定符（如const）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#友元（可以访问类中的私有成员）"><span class="toc-text">友元（可以访问类中的私有成员）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#全局函数做友元"><span class="toc-text">全局函数做友元</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#类做友元"><span class="toc-text">类做友元</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#成员函数做友元"><span class="toc-text">成员函数做友元</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运算符重载（加法）"><span class="toc-text">运算符重载（加法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运算符重载（左移运算符）"><span class="toc-text">运算符重载（左移运算符）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编译器默认提供的类的函数"><span class="toc-text">编译器默认提供的类的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运算符重载（赋值运算）"><span class="toc-text">运算符重载（赋值运算）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承方式"><span class="toc-text">继承方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用开发人员命令提示工具查看对象模型"><span class="toc-text">利用开发人员命令提示工具查看对象模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#子类中同名属性的访问"><span class="toc-text">子类中同名属性的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多继承"><span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#父类的引用指向子类的对象"><span class="toc-text">父类的引用指向子类的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态多态（父类函数前加virtual）"><span class="toc-text">动态多态（父类函数前加virtual）</span></a></li></ol></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="c-学习——By-Xie"><a href="#c-学习——By-Xie" class="headerlink" title="c++学习——By Xie"></a>c++学习——By Xie</h1><p>以下均为学习b站黑马程序员C++所做笔记，以及简单的学习心得<br><a href="https://www.bilibili.com/video/BV1et411b73Z" target="_blank" rel="noopener">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难</a></p>
<h4 id="VS使用技巧"><a href="#VS使用技巧" class="headerlink" title="VS使用技巧"></a>VS使用技巧</h4><p>注释：     先<strong>CTRL+K</strong>，然后<strong>CTRL+C</strong>          或者加//</p>
<p>取消注释： 先<strong>CTRL+K</strong>，然后<strong>CTRL+U</strong>    或者删除//</p>
<p>调试：<strong>F5</strong></p>
<p>单步执行：<strong>F10</strong></p>
<p>设置或者删除断点：<strong>F9</strong></p>
<p>查找：<strong>CTRL+Shift+F</strong></p>
<p>跳转到变量/函数的定义：<strong>F12</strong></p>
<pre><code>system(&quot;pause&quot;)   //显示按任意键继续
system(&quot;cls&quot;)     //清屏</code></pre><p>程序执行到return,会直接跳出该函数</p>
<h4 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h4><p>sizeof（数据类型/变量名）</p>
<pre><code>int arr[10]={、、、};
int a= sizeof(arr)/sizeof(arr[0]);     //常用来求数组元素个数</code></pre><h4 id="float-单精度浮点型"><a href="#float-单精度浮点型" class="headerlink" title="float 单精度浮点型"></a>float 单精度浮点型</h4><pre><code>float f1 = 3.14f; //常在末尾加上f，表示单精度
double f2 = 3.14; //在double中常省略</code></pre><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>字符型变量用于显示<strong>单个</strong>字符</p>
<pre><code>char ch = &apos;a&apos;; //单引号中只能有一个字母</code></pre><p>查看对应的ASCII码值</p>
<pre><code>cout &lt;&lt; (int)ch &lt;&lt; endl; //强制类型转换
//A——65；a——97</code></pre><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><pre><code>\n  换行
\t  水平制表符      和前面的总共构成8个空格，整齐地输出后面的内容
\\  反斜杠字符</code></pre><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><pre><code>char str[] = &quot;hello world&quot;;
string str2 = &quot;hello world&quot;; //两种创建方式    第二种方式要加头文件 #include &lt;string&gt;</code></pre><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><pre><code>/*
true  （本质是数字1）
false （本质是数字0）
*/
bool flag = true</code></pre><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>两个整数相除，结果依然为整数，直接舍弃小数（没有四舍五入）</p>
<pre><code>int a = 10;
int b = 20;
cout &lt;&lt; a/b &lt;&lt; endl //结果为0

double d1 = 0.5;
double d2 = 0.22;
cout &lt;&lt; d1/d2 &lt;&lt; endl;   //2.27273</code></pre><h4 id="取模（取余）运算"><a href="#取模（取余）运算" class="headerlink" title="取模（取余）运算"></a>取模（取余）运算</h4><pre><code>%
//小数不能做取模运算</code></pre><h4 id="递增"><a href="#递增" class="headerlink" title="递增"></a>递增</h4><pre><code>int a1 =10;
int a2 = ++a1 * 10; //前置递增，先让变量+1，然后进行表达式的计算   a1=11,a2=110
int b1 = 10;
int b2 = b1++ *10; //后置递增，先进行表达式的计算，再让变量+1   b1=11,b2=100</code></pre><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><pre><code>// ！非    &amp;&amp;与   ||或</code></pre><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><pre><code>int a=10;
int b=100;
int c=0;
c = ( a&lt;b ? a:b); //将较小值赋值给c

//三目运算符返回的是变量，可以继续赋值
（a&lt;b ? a:b) = 100;   //a=100</code></pre><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><pre><code>switch(表达式（变量）  字符型/整型)
{
case1:
case2:
    、、、;  //1和2执行相同的语句
    break;  //没有break，会一直执行后面的语句
、、、
default:
    、、、;  //没有对应的case则执行default

}</code></pre><h4 id="rand-生成伪随机整数"><a href="#rand-生成伪随机整数" class="headerlink" title="rand( )生成伪随机整数"></a>rand( )生成伪随机整数</h4><pre><code>//通用公式： a + rand()% n，a为起始整数，n为能取到的整数个数
/*例如：[1,100]生成随机数：1+rand()%100;
       (1,100]生成随机数：2+rand()%99;
       (1,100)生成随机数：2+rand()%98;</code></pre><h4 id="srand-生成真随机数"><a href="#srand-生成真随机数" class="headerlink" title="srand( )生成真随机数"></a>srand( )生成真随机数</h4><pre><code>//根据当前系统时间生成随机数
#include &lt;ctime&gt;

srand((unsigned int)time(NULL));

int a = 1+rand()%100;</code></pre><h4 id="取出各位上的数字"><a href="#取出各位上的数字" class="headerlink" title="取出各位上的数字"></a>取出各位上的数字</h4><pre><code>/*从多位数（例如：n=2456）取出各个位数上的数字
个位：对10取模   int a = n%10;
最高位：除以10的位数-1次方   int b = n/1000;
其他位：除以10的对应次方，再对10取模  取出十位数字： int c = n/10%10;
                                取出百位数字： int d = n/100%10;  间接变成取出个位数字
 */                </code></pre><h4 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h4><pre><code>pow(10.0,3);   //10的3次方`</code></pre><h4 id="for循环的省略"><a href="#for循环的省略" class="headerlink" title="for循环的省略"></a>for循环的省略</h4><pre><code>//输出0到9所有整数
int i = 0;    
for(; ; ;)
{
    if(i&gt;9)
    {
        break;
    }
    、、、;
    i++;
}</code></pre><p>for (   <strong><em>0</em></strong>int i=0;   <strong><em>1</em></strong> i&lt;10;  <strong><em>3</em></strong> i++)<br>{<br>        <strong><em>2</em></strong>、、、;<br>}      //执行顺序为0 1 2 3 1 2 3……..</p>
<h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>难点是在循环条件的书写，循环嵌套需要做的大体都是一个方形（可能不完整），行用 i 来控制，列用 j 来控制，且每一次 j 循环时 i 为定值，for( ) 循环常用计算需要循环的次数来确定循环条件，特别需要注意 j 关于 i 的通式的书写。</p>
<h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><pre><code>//三种定义方式
/*     数组类型 数组名[数组长度];    int a[4];
    数组类型 数组名[数组长度] = {、、、}； int a[4]={1,2,3,4};
    数组类型 数组名[] ={、、、};   int a[]={1,2,3,4};

数组中每个元素类型相同
数组名是首元素的地址，是个常量
*/

int arr[5]= {10,20,30,40,50};
cout &lt;&lt; arr&lt;&lt;endl;     //输出为第一个元素地址   等同于 cout&lt;&lt; &amp;arr[0] &lt;&lt;endl;
cout&lt;&lt;(int)arr&lt;&lt;endl;  //以十进制输出</code></pre><h4 id="删除数组中的一个元素"><a href="#删除数组中的一个元素" class="headerlink" title="删除数组中的一个元素"></a>删除数组中的一个元素</h4><pre><code>//遍历数组，如果某个元素和输入的相同，则删除该元素。可以分成两部分，第一个函数实现查找功能，变量a返回该元素在数组中的序号，没找到则返回-1
//实现删除功能的函数接收返回变量，删除可以用后一个元素覆盖前一个来实现，for循环变量i从a开始到元素数（或者元素数-1）
//最后数组元素数-1
int is_exist(int* arr,int len)
{
    for (int i = 0; i &lt; len; i++)
    {
        if (arr[i] == 6)
        {
            return i;
        }

    }
    return -1;
}   //一定要在for循环遍历整个数组发现没有该值后，再return -1</code></pre><h4 id="求数组元素个数"><a href="#求数组元素个数" class="headerlink" title="求数组元素个数"></a>求数组元素个数</h4><pre><code>int arr[]={1,2,3,4,5};
int a = sizeof(arr)/sizeof(arr[0]);</code></pre><h4 id="数组前后依次交换元素值"><a href="#数组前后依次交换元素值" class="headerlink" title="数组前后依次交换元素值"></a>数组前后依次交换元素值</h4><pre><code>//从下标的角度思考，下标来移动，循环条件为 start &lt; end
int arr[5]={1,2,3,4,5};
int start =0; //首下标
int end = sizeof(arr)/sizeof(arr[0])-1; //尾下标
int a = 0;   //存储中间变量
// 、、、、;</code></pre><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><pre><code>//6个数升序排列，进行5轮(外层循环 i=0，1，2，3，4)，每轮比较的次数n-i-1 (j的表达式)
//输入回车开始排序
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

void maopao(int* p, int len)       //冒泡排序
{
    for (int i = 0; i &lt; len - 1; i++)
    {
        for (int j = 0; j &lt; len - i - 1; j++)
        {
            if (p[j] &lt; p[j + 1])
            {
                int a = p[j];
                p[j] = p[j + 1];
                p[j + 1] = a;
            }
        }
    }
}
int main()
{
    int i = 0;
    int arr[20]  ;            //预先指定数组大小
    while (cin.peek() != &apos;\n&apos;)         //键入回车跳出循环
    {
        cin &gt;&gt; arr[i];
        i++;
    }
    int len = i;
    cout &lt;&lt; i&lt;&lt;endl;
    maopao(arr, len);
    for (int j = 0; j &lt; len; j++)
    {
        cout &lt;&lt; arr[j] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="数组作为参数传递给函数"><a href="#数组作为参数传递给函数" class="headerlink" title="数组作为参数传递给函数"></a>数组作为参数传递给函数</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

void aaa(int arr[], int len)       //第一种方式 值传递
{
    for (int i = 0; i &lt; len; i++)
    {
        cout &lt;&lt; arr[i]&lt;&lt;&quot; &quot;;
    }
    cout &lt;&lt; endl;
}
int main()
{
    int arr[] = { 1,2,3,4,5 };
    int len = sizeof(arr) / sizeof(arr[0]);
    aaa(arr, len);

    system(&quot;pause&quot;);
    return 0;
}

#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

void aaa(int *arr, int len)     //第二种方式 地址传递
{
    for (int i = 0; i &lt; len; i++)
    {
        cout &lt;&lt; arr[i]&lt;&lt;&quot; &quot;;
    }
    cout &lt;&lt; endl;
}
int main()
{
    int arr[] = { 1,2,3,4,5 };
    int len = sizeof(arr) / sizeof(arr[0]);
    aaa(arr, len);

    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="二维数组名称"><a href="#二维数组名称" class="headerlink" title="二维数组名称"></a>二维数组名称</h4><pre><code>//查看内存空间
int arr[2][3]= {{1,2,3},{4,5,6}}
cout &lt;&lt; sizeof(arr) &lt;&lt;endl;    //数组占用的总内存空间
cout &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; //第一行所占内存空间

cout &lt;&lt; sizeof(arr)/sizeof(arr[0]);   //二维数组行数
cout &lt;&lt; sizeof(arr[0])/sizeof([0][0]); //二维数组列数

//首元素地址
cout &lt;&lt; (int)arr &lt;&lt;endl; //数组首地址
cout &lt;&lt; (int)arr[0] &lt;&lt;endl; //第一行首地址
cout &lt;&lt; &amp;(int)arr[0][0] &lt;&lt; endl; //第一个元素首地址</code></pre><h4 id="二维数组加法"><a href="#二维数组加法" class="headerlink" title="二维数组加法"></a>二维数组加法</h4><p>做加法时，不要用arr[i] [j]+arr[i] [j+1]，而是</p>
<pre><code>int sum =0;//定义一个变量作为和
for(int i=0;i&lt;、、、;i++)
{
    for(int j=0;j&lt;、、、;j++)
    {
        sum +=arr[i][j];
    }
}</code></pre><h4 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h4><p>数组的每一个元素为一个字符串，且不要求长度相同</p>
<pre><code>string arr[3]={&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;};</code></pre><h4 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h4><pre><code>void test(int a,int b)        //形参接收实参时，int a=c,int b=d;
{
    cout&lt;&lt;a+b&lt;&lt;endl;
}

int main()
{
    int c=10;
    int d=20;
    test(c,d);
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="函数分文件编写"><a href="#函数分文件编写" class="headerlink" title="函数分文件编写"></a>函数分文件编写</h4><p>1、创建 .h 的头文件，在其中写函数声明</p>
<p>2、创建 .cpp 的源文件，在其中写函数的定义</p>
<p>.h文件</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
void swap(int a, int b);  //函数声明</code></pre><p>.cpp文件</p>
<pre><code>#include &quot;swap.h&quot;

void swap(int a, int b)         //函数定义
{
    int c = a;
    a = b;
    b = c;
    cout &lt;&lt; &quot;a的值为&quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;b的值为&quot; &lt;&lt; b &lt;&lt; endl;

}</code></pre><p>在主.cpp文件中再加上#include “swap.h” ，即可调用函数</p>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><pre><code>int a=10;     //整型变量要定义整型
int * p = &amp;a;  //p中存的是a的地址
*p = 100;   //解引用，修改指针所指向的内存中的数据     a=100;
//指针也是一种数据类型，表示为int *、float *等，变量名为p，和整型、字符型、字符串一样。sizeof(int *)，sizeof(p)。</code></pre><h4 id="指针常量和常量指针"><a href="#指针常量和常量指针" class="headerlink" title="指针常量和常量指针"></a>指针常量和常量指针</h4><pre><code>const int * p = &amp;a;  //常量指针    与int const *p = &amp;a完全相同
*p =10; //错误    值只能读取，不能修改，防止误操作
p = &amp;b; //正确
const struct student *s;
s-&gt;age = 18; //错误，结构体变量中的值不能修改


int * const p = &amp;a;  //指针常量
p = &amp;a; //错误
*p = 10; //正确</code></pre><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p>形参的改变不影响实参的值</p>
<h4 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h4><p>用指针接收变量的地址，修改以后值会发生改变</p>
<p>结构体作为函数参数时，地址传递以指针来接收有利于减少内存空间</p>
<h4 id="指针-冒泡排序（升序）"><a href="#指针-冒泡排序（升序）" class="headerlink" title="指针+冒泡排序（升序）"></a>指针+冒泡排序（升序）</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;


void swap(int* p,int N)
{
    int* p2 = p;
    for (int i = 0; i &lt; N - 1; i++)
    {
        for (int j = 0; j &lt; N - i-1; j++)
        {
            if (*p2 &gt; * (p2 + 1))
            {
                int c = *p2;
                *p2 = *(p2 + 1);
                *(p2 + 1) = c;
            }
            p2++;
        }
        p2 =p;
    }
}

int main()
{
    int arr[] = { 4,3,1,2,8,7,10,9,5,6 };
    int N = sizeof(arr) / sizeof(arr[0]);    //数组长度
    swap(arr,N);
    for (int k = 0; k &lt; N; k++)
    {
        cout &lt;&lt; arr[k]&lt;&lt;&quot; &quot;&lt;&lt;endl;
    }
    system(&quot;pause&quot;);
    return 0;

}




//指针的两种访问数组值的方式
int *p =arr;
cout &lt;&lt; p[2];

int *p =arr;
cout &lt;&lt; *(p+2);     //且这两种方式使用后并不改变 p 指向首地址


#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;


void swap(int* p,int N)
{
    for (int i = 0; i &lt; N - 1; i++)
    {
        for (int j = 0; j &lt; N - i-1; j++)
        {
            if (p[j] &gt;  p[j+1])
            {
                int c = p[j];
                p[j] = p[j + 1];
                p[j + 1] = c;
            }
        }
    }
}

int main()
{
    int arr[] = { 4,3,1,2,8,7,10,9,5,6 };
    int N = sizeof(arr) / sizeof(arr[0]);
    swap(arr,N);
    for (int k = 0; k &lt; N; k++)
    {
        cout &lt;&lt; arr[k]&lt;&lt;&quot; &quot;&lt;&lt;endl;
    }
    system(&quot;pause&quot;);
    return 0;

}</code></pre><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><pre><code>struct student
{
    string name;    //姓名
    int age;        //年龄
    int score;        //分数
};    //结构体定义   定义时struct关键字不可省略    定义好之后类似于一个数据类型，后面跟变量名可以直接赋值



//结构体变量创建  struct关键字可省略
student s1;
s1.name = &quot;lalala&quot;;
s1.age = 16;
s1.score = 87;

struct student s2={&quot;lalalala&quot;, 17, 98};</code></pre><h4 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h4><p>结构体定义没有区别，变量名变成了一个数组名，数组中的每个元素类型是一个结构体</p>
<pre><code>//创建结构体数组

struct student arr[3]=
{
    {&quot;张三&quot;,16,90},
    {&quot;李四&quot;,18,70}，
    {&quot;王五&quot;,19,80}
}；
arr[0].age =20;    //仍用变量名. 来访问，用for循环来遍历</code></pre><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><p>结构体定义没有区别</p>
<pre><code>//结构体变量创建
struct student s ={&quot;张三&quot;, 17, 90};
struct student *p = &amp;s;

cout &lt;&lt; &quot;姓名：&quot;&lt;&lt; p-&gt;name &lt;&lt; endl;</code></pre><h4 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h4><pre><code>//定义
struct student 
{
    string name;
    int age;
    int score;
}
struct teacher
{
    int id;
    string name;
    struct student stu;
}


//创建变量
struct teacher t;
t.id = 1000;
t.name = &quot;啦啦啦&quot;;
t.stu.name =&quot;哦哦哦&quot;;
t.stu.age = 17;
t.stu.score =90;</code></pre><h4 id="结构体数组嵌套"><a href="#结构体数组嵌套" class="headerlink" title="结构体数组嵌套"></a>结构体数组嵌套</h4><p>三个老师每个人带三个学生</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;


struct student
{
    string name;    //姓名
    int score;        //分数
};

struct teacher
{
    string name;
    struct student arr[3];
};


int main()
{
    struct teacher arr1[3];     //难点
    for (int k = 0; k &lt; 3; k++)
    {
        cout &lt;&lt; &quot;请输入第&quot;&lt;&lt;k+1&lt;&lt;&quot;个老师姓名：&quot; &lt;&lt; endl;
        cin &gt;&gt; arr1[k].name;
        for(int i=0;i&lt;3;i++)
        {
            cout &lt;&lt; &quot;请输入他第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;个学生的姓名&quot; &lt;&lt; endl;
            cin &gt;&gt; arr1[k].arr[i].name;
            cout &lt;&lt; &quot;请输入他第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;个学生的成绩&quot; &lt;&lt; endl;
            cin &gt;&gt; arr1[k].arr[i].score;
        }

    }

    for (int j = 0; j &lt; 3; j++)
    {
        cout &lt;&lt; &quot;第&quot; &lt;&lt; j + 1 &lt;&lt; &quot;个老师是：&quot; &lt;&lt; arr1[j].name &lt;&lt; endl;
        for (int b = 0; b &lt; 3;b++)
        {
            cout &lt;&lt; &quot;他的第&quot; &lt;&lt; b + 1 &lt;&lt; &quot;个学生是：&quot; &lt;&lt;arr1[j].arr[b].name&lt;&lt; &quot;  &quot; 
            &lt;&lt; &quot;成绩为：&quot; &lt;&lt; arr1[j].arr[b].score &lt;&lt; endl;
        }

    }

    system(&quot;pause&quot;);
    return 0;

}</code></pre><h4 id="根据某项元素对结构体数组排序"><a href="#根据某项元素对结构体数组排序" class="headerlink" title="根据某项元素对结构体数组排序"></a>根据某项元素对结构体数组排序</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

struct hero
{
    string name;
    int age;
    string gender;
};

void bubblesort(hero *arr, int len)       //按年龄对英雄排序
{
    for (int i = 0; i &lt; len-1; i++)
        {
            for (int j = 0; j &lt; len-1 - i; j++)
            {
                if (arr[j].age &gt; arr[j + 1].age)
                {
                    hero a = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = a;
                }
            }
        }
    for (int k = 0; k &lt; 5; k++)
    {
        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[k].name &lt;&lt; &quot; &quot; &lt;&lt; &quot;年龄&quot; &lt;&lt;
    arr[k].age &lt;&lt; &quot; &quot; &lt;&lt; &quot;性别&quot; &lt;&lt; arr[k].gender &lt;&lt; endl;
    }
}

int main()
{
    struct hero arr[] =
    {
        {&quot;刘备&quot;,23,&quot;男&quot;},
        {&quot;关羽&quot;,22,&quot;男&quot;},
        {&quot;张飞&quot;,20,&quot;男&quot;},
        {&quot;赵云&quot;,21,&quot;男&quot;},
        {&quot;貂蝉&quot;,19,&quot;女&quot;}
    };           //五个数冒泡排序
    int len = sizeof(arr) / sizeof(arr[0]);
    bubblesort(arr, len);


    system(&quot;pause&quot;);
    return 0;

}</code></pre><h4 id="无参数调用"><a href="#无参数调用" class="headerlink" title="无参数调用"></a>无参数调用</h4><pre><code>void showMenu()
{
    cout &lt;&lt; &quot;1、添加联系人&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;2、显示联系人&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;3、删除联系人&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;4、查找联系人&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;5、修改联系人&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;6、清空联系人&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;0、退出该系统&quot; &lt;&lt; endl;
}

int main()
{
    showMenu();        //括号不能省略
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="实例——通讯录管理系统"><a href="#实例——通讯录管理系统" class="headerlink" title="实例——通讯录管理系统"></a>实例——通讯录管理系统</h4><pre><code>#include&lt;iostream&gt;
using namespace std;


struct aaa           //联系人结构体
{
    string name;
    string sex;
    int age;
    string phonenumber;
    string address;
};

struct bbb        //通讯录结构体
{
    struct aaa arr[1000];
    int size;    //当前通讯录中人员个数     
};

void showMenu()
{
    cout &lt;&lt; &quot;1、添加联系人&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;2、显示联系人&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;3、删除联系人&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;4、查找联系人&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;5、修改联系人&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;6、清空联系人&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;0、退出该系统&quot; &lt;&lt; endl;
}

void add_people(bbb *t)
{
    int z = t-&gt;size;
    cout &lt;&lt; &quot;请输入姓名：&quot; &lt;&lt; endl;
    cin &gt;&gt; t-&gt;arr[z].name;
    cout &lt;&lt; &quot;请输入性别：&quot; &lt;&lt; endl;
    cin &gt;&gt; t-&gt;arr[z].sex;
    cout &lt;&lt; &quot;请输入年龄：&quot;&lt;&lt;endl;
    cin &gt;&gt; t-&gt;arr[z].age;
    cout &lt;&lt; &quot;请输入电话：&quot; &lt;&lt; endl;
    cin &gt;&gt; t-&gt;arr[z].phonenumber;
    cout &lt;&lt; &quot;请输入地址：&quot; &lt;&lt; endl;
    cin &gt;&gt; t-&gt;arr[z].address;
    t-&gt;size++;

}

void show_people(bbb t)
{
    if (t.size == 0)
    {
        cout &lt;&lt; &quot;当前联系人为空&quot; &lt;&lt; endl;

    }
    else
    {
        for (int i = 0; i &lt; t.size; i++)
        {
            cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; t.arr[i].name &lt;&lt; &quot; &quot; &lt;&lt; &quot;性别：&quot; &lt;&lt; t.arr[i].sex &lt;&lt; &quot; &quot; &lt;&lt; &quot;年龄：&quot; &lt;&lt; t.arr[i].age
                &lt;&lt; &quot; &quot; &lt;&lt; &quot;电话：&quot; &lt;&lt; t.arr[i].phonenumber &lt;&lt; &quot; &quot; &lt;&lt; &quot;地址：&quot; &lt;&lt; t.arr[i].address &lt;&lt; endl;
        }
    }
}

int is_exist(bbb* t, string name)
{
    int i = 0;
    for (; i &lt; t-&gt;size; i++)
    {
        if (t-&gt;arr[i].name == name)
        {
            return i;
        }
    }
    return -1;

}       //多个功能都涉及到查找，返回数组元素下标

void delete_people(bbb* t)
{
    string name;
    cout &lt;&lt; &quot;请输入想要删除的联系人姓名：&quot;;
    cin &gt;&gt; name;
    int a = is_exist(t, name);
    if (a == -1)
    {
        cout &lt;&lt; &quot;查无此人！&quot; &lt;&lt; endl;
    }
    else
    {
        for (int i = a; i &lt; t-&gt;size; i++)
        {
            t-&gt;arr[i] = t-&gt;arr[i + 1];

        }
        t-&gt;size--;
    }
}
void find_people(bbb *t)
{
    string name;
    cout &lt;&lt; &quot;请输入想查找的联系人：&quot; &lt;&lt; endl;
    cin &gt;&gt; name;
    int a = is_exist(t, name);
    if (a == -1)
    {
        cout &lt;&lt; &quot;查无此人！&quot; &lt;&lt; endl;
    }
    else
    {
        cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;t-&gt;arr[a].name&lt;&lt;&quot; &quot; &lt;&lt; &quot;性别：&quot; &lt;&lt; t-&gt;arr[a].sex &lt;&lt; &quot; &quot; &lt;&lt; &quot;年龄：&quot; &lt;&lt; t-&gt;arr[a].age
            &lt;&lt; &quot; &quot; &lt;&lt; &quot;电话：&quot; &lt;&lt; t-&gt;arr[a].phonenumber &lt;&lt; &quot; &quot; &lt;&lt; &quot;地址：&quot; &lt;&lt; t-&gt;arr[a].address &lt;&lt; endl;
    }
}

void modify_people(bbb *t)
{
    string name;
    cout &lt;&lt; &quot;请输入想修改的联系人姓名：&quot; &lt;&lt; endl;
    cin &gt;&gt; name;
    int a = is_exist(t, name);
    if (a == -1)
    {
        cout &lt;&lt; &quot;查无此人！&quot; &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; &quot;请重新输入姓名：&quot; &lt;&lt; endl;
        cin &gt;&gt; t-&gt;arr[a].name;
        cout &lt;&lt; &quot;请输入性别&quot; &lt;&lt; endl;
        cin &gt;&gt; t-&gt;arr[a].sex;
        cout &lt;&lt; &quot;请输入年龄&quot; &lt;&lt; endl;
        cin &gt;&gt; t-&gt;arr[a].age;
        cout &lt;&lt; &quot;请输入电话：&quot; &lt;&lt; endl;
        cin &gt;&gt; t-&gt;arr[a].phonenumber;
        cout &lt;&lt; &quot;请输入地址&quot; &lt;&lt; endl;
        cin &gt;&gt; t-&gt;arr[a].address;

    }
}

void clean_out(bbb* t)
{
    cout &lt;&lt; &quot;您是否确认要清空通讯录  1——是   2——否&quot; &lt;&lt; endl;
    int s;
    cin &gt;&gt; s;
    if (s == 1)
    {
        t-&gt;size = 0;
        cout &lt;&lt; &quot;通讯录已清空！&quot; &lt;&lt; endl;
    }

}
int main()
{

    struct bbb  t;
    t.size = 0;
    int select;
    while (1)
    {
        showMenu();
        cin &gt;&gt; select;
        string abc;
        switch (select)
        {
        case 1:
            add_people(&amp;t);
            break;
        case 2:
            show_people(t);
            break;
        case 3:
            delete_people(&amp;t);
            break;
        case 4:
            find_people(&amp;t);
            break;
        case 5:
            modify_people(&amp;t);
            break;
        case 6:
            clean_out(&amp;t);
            break;
        case 0:
            cout &lt;&lt; &quot;再见！&quot; &lt;&lt; endl;
            system(&quot;pause&quot;);
            return 0;
        default:
            break;


        }
        system(&quot;pause&quot;);
        system(&quot;cls&quot;);
    }

    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="变量（常量）都在哪"><a href="#变量（常量）都在哪" class="headerlink" title="变量（常量）都在哪"></a>变量（常量）都在哪</h4><pre><code>const int c_g_a=10;   //const修饰的全局变量——全局常量——全局区
int g_a=10;    //全局变量——全局区


int main()
{
    int l_a=10;   //局部变量——非全局区（栈区）
    static a=10;   //静态变量——全局区
    &quot;hello&quot;;   //字符串常量——全局区
    const int c_l_a=10;   //const修饰的局部变量——局部常量——非全局区（栈区）


    system(&quot;pause&quot;);
    return 0;
}
//栈区数据（局部变量和形参）由编译器管理开辟和释放，该函数执行完自动释放，故不要返回局部变量的地址</code></pre><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><pre><code>//由程序员管理开辟和释放


int * func()
{
    int * p = new int(10);   
    //该指针是局部变量，存放在栈区，指针中地址存放的数在堆区，new将数据开辟到堆区，返回其地址
    return p;
}
int main()
{
    int *p =func();
    cout&lt;&lt;*p&lt;&lt;endl;
    delete p;   //释放
}</code></pre><h4 id="堆区创建数组"><a href="#堆区创建数组" class="headerlink" title="堆区创建数组"></a>堆区创建数组</h4><pre><code>int* func()
{
    int *p = new int[5];
    for(int i=0;i&lt;5;i++)
    {
        cin&gt;&gt;p[i];
    }
    return p;
}


int main()
{
    int *arr=func();
    for(int j=0;j&lt;5;j++)
    {
        cout&lt;&lt;arr[j];
    }
    cout&lt;&lt;endl;
    delete[] arr;    //释放堆区的数组，且不是delete[] p

    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><pre><code>//引用必须初始化，且之后不可改变
int a=10;
int &amp;b=a;      //引用的本质是指针常量 int *const b=&amp;a;    b中存放的始终是a的地址，且可以通过*b去改变a的值</code></pre><h4 id="引用做函数参数-形参"><a href="#引用做函数参数-形参" class="headerlink" title="引用做函数参数(形参)"></a>引用做函数参数(形参)</h4><pre><code>//以引用的方式接收实参，让形参可以修饰实参
void exchange(int &amp;a, int &amp;b)     
{

    int c = a;
    a = b;
    b = c;


}


int main()
{
    int a = 10;
    int b = 20;
    exchange(a, b);             //int &amp;a=a;   别名也叫a
    cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;       //a=20,b=10

    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="引用做返回值"><a href="#引用做返回值" class="headerlink" title="引用做返回值"></a>引用做返回值</h4><pre><code>int&amp; test()
{

    static int a = 10;
    return a;             //返回a的引用，才能用别名去接收，且不要返回局部变量的引用


}


int main()
{
    int &amp;b = test();      //b是a的引用
    test() = 1000;        //函数做左值，则必须返回引用；对原名进行操纵
    cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;    //别名的值也会改变
                                  //b=1000
    system(&quot;pause&quot;);
    return 0;
}


//错误案例
int test()
{

    static int a = 10;
    return a;


}

int main()
{

    test() = 1000;       //返回原值，函数不能直接做左值
    //cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;

    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h4><pre><code>void test(const int &amp;b)       
{
    //b=40;   错误的，不允许通过别名再修改 const int &amp;b=30,只给只读权限，防止误操作
    cout &lt;&lt; &quot;b=&quot; &lt;&lt; b&lt;&lt;endl;

}


int main()
{
    int a = 30;
    test(a);


    system(&quot;pause&quot;);
    return 0;
}

//cont int &amp;b=30  相当于int a=30;     const int &amp;b=a;</code></pre><h4 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h4><pre><code>void test(int a,int b,int c);     //函数的声明和实现只能有一个有默认参数

void test(int a, int b = 10, int c = 30)    //默认参数必须放在最后，就是有默认参数的形参右侧的形参必须都有默认参数
{
    cout &lt;&lt; a + b + c &lt;&lt; endl;
}

int main()
{
    test(10, 20);      //使用用户提供的值，10+20+30
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h4><pre><code>//二者唯一的区别是结构体在默认情况下成员是公共的，类在默认情况下成员是私有的（但是都可以自定义）

#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

struct student                  //学生结构体
{
    string name;
    string number;
    void show()
    {
        cout &lt;&lt; &quot;姓名为：&quot; &lt;&lt; name &lt;&lt; endl;
        cout &lt;&lt; &quot;学号为：&quot; &lt;&lt; number &lt;&lt; endl;
    }
};

int main()
{
    student s1;
    s1.name = &quot;张三&quot;;
    s1.number = &quot;123456&quot;;
    s1.show();

    system(&quot;pause&quot;);
    return 0;
}





#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class student                //学生类
{
public:
    string name;
    string number;             //两个属性：姓名和学号
    void show()                   //行为：打印出姓名和学号
    {
        cout &lt;&lt; &quot;姓名为：&quot; &lt;&lt; name &lt;&lt; endl;
        cout &lt;&lt; &quot;学号为：&quot; &lt;&lt; number &lt;&lt; endl;
    }
};

int main()
{
    student s1;           //通过类创建出一个具体的学生
    s1.name = &quot;张三&quot;;
    s1.number = &quot;123456&quot;;
    s1.show();

    system(&quot;pause&quot;);
    return 0;
}
//构造一个类，相当于一个新的数据类型，它下面又包含一系列基本数据类型（int/string能存在的地方，它基本都能在）</code></pre><h4 id="类成员的访问权限"><a href="#类成员的访问权限" class="headerlink" title="类成员的访问权限"></a>类成员的访问权限</h4><p>1、public</p>
<p>类内可访问、类外可访问</p>
<p>2、protected</p>
<p>类内可访问、类外不可访问，继承该类的子类可以访问</p>
<p>3、private</p>
<p>类内可访问、类外不可访问，继承该类的子类不可访问</p>
<h4 id="中途退出函数"><a href="#中途退出函数" class="headerlink" title="中途退出函数"></a>中途退出函数</h4><pre><code>//函数遇到return关键字会直接退出，不再执行剩下的语句
void test(int age)
{
    if(age&lt;0 || age&gt;150)
    {
        cout&lt;&lt;&quot;输入有误！&quot;&lt;&lt;endl;
        return;         //直接退出函数
    }
    else
    {
        //、、、;
    }
    //、、、;
}</code></pre><h4 id="成员函数和全局函数"><a href="#成员函数和全局函数" class="headerlink" title="成员函数和全局函数"></a>成员函数和全局函数</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class cube //学生结构体
{
public:
    //设置长
    void set_l(double l)       //成员函数（行为）
    {
        m_l = l;
    }
    //获取长
    double get_l()
    {
        return m_l;
    }
    //设置宽
    void set_w(double w)
    {
        m_w = w;
    }
    //获取宽
    double get_w()
    {
        return m_w;
    }
    //设置高
    void set_h(double h)
    {
        m_h= h;
    }
    //获取高
    double get_h()
    {
        return m_h;
    }
    //获得表面积
    double get_square()
    {
        double square = (m_l * m_h + m_l * m_w + m_h * m_w) * 2;
        return square;
    }
    //获得体积
    double get_volume()
    {
        double volume = m_l * m_h * m_w;
        return volume;
    }
    //利用成员函数比较两个立方体是否完全相同
    bool panduan(cube &amp;c)
    {
        if (m_l == c.get_l() &amp;&amp; m_h == c.get_h() &amp;&amp; m_w == c.get_w())
        {
            return true;
        }
        else
        {
            return false;
        }
    }
private:
    double m_l;         //成员变量（属性）
    double m_w;
    double m_h;

};
//全局函数判断是否相等
bool issame(cube &amp;c1,cube &amp;c2)
{

    if (c1.get_l() == c2.get_l() &amp;&amp; c1.get_h()== c2.get_h() &amp;&amp; c1.get_w() == c2.get_w())
    {
        return true;
    }
    else
    {
        return false;
    }
}
int main()
{
    cube c1;         //定义对象
    c1.set_l(2.0);
    c1.set_w(3.0);
    c1.set_h(4.0);
    double s = c1.get_square();//表面积
    cout &lt;&lt; &quot;表面积为：&quot; &lt;&lt; s &lt;&lt; endl;
    double v = c1.get_volume();
    cout &lt;&lt; &quot;体积为：&quot; &lt;&lt; v &lt;&lt; endl;

    cube c2;
    c2.set_l(2.0);
    c2.set_w(3.0);
    c2.set_h(3.0);

    bool b = issame(c1, c2);
    if (b)
    {
        cout &lt;&lt; &quot;两个立方体完全相同&quot; &lt;&lt; endl;
    }
    else 
    {
        cout &lt;&lt; &quot;两个立方体不相同&quot; &lt;&lt; endl;
    }
    bool d = c1.panduan(c2);      //关键点，c1结构体去调用函数，传入参数为c2，比较c1和c2的长、宽、高
    cout &lt;&lt; d;
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="类的嵌套"><a href="#类的嵌套" class="headerlink" title="类的嵌套"></a>类的嵌套</h4><pre><code>//判断点和圆的位置关系
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Point
{
public:
    //设置点x坐标
    void set_p_x(int x)
    {
        p_x = x;
    }
    //设置点y坐标
    void set_p_y(int y)
    {
        p_y = y;
    }
    //获取点x坐标
    int get_p_x()
    {
        return p_x;
    }
    //获取点y坐标
    int get_p_y()
    {
        return p_y;
    }
private:
    int p_x;   //点x坐标
    int p_y;   //点y坐标
};
class Circle       //圆类
{
public:
    //设置圆心坐标
    void set_c_p(Point p)
    {
        c_p = p;
    }
    //获取圆心
    Point get_c_p()
    {

        return c_p;
    }
    //设置半径
    void set_r(int r)
    {
        c_r = r;
    }
    //获取半径
    int get_r()
    {
        return c_r;
    }
private:
    Point c_p; //圆心坐标
    int c_r;    //半径

};
//全局函数确定点和圆的位置关系
void panduan(Circle&amp; c, Point&amp; p)
{
    int c_x = c.get_c_p().get_p_x();  // 圆心x
    int c_y = c.get_c_p().get_p_y();//圆心y
    int r = c.get_r(); //半径
    int p_x = p.get_p_x();
    int p_y = p.get_p_y();
    int d2 = (c_x - p_x) * (c_x - p_x) + (c_y - p_y) * (c_y - p_y);
    if (d2 == (r*r))
    {
        cout &lt;&lt; &quot;点在圆上&quot; &lt;&lt; endl;
    }
    else if (d2 &lt; (c.get_r() * c.get_r()))
    {
        cout &lt;&lt; &quot;点在圆内&quot; &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; &quot;点在圆外&quot; &lt;&lt; endl;
    }
}
int main()
{

    Point p;   //点
    p.set_p_x(3);
    p.set_p_y(0);

    Circle c;    //圆
    c.set_r(3);
    Point c_p;
    c_p.set_p_x(0);
    c_p.set_p_y(0);
    c.set_c_p(c_p);
    panduan(c, p);
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="分文件编写"><a href="#分文件编写" class="headerlink" title="分文件编写"></a>分文件编写</h4><pre><code>//circle.h

#pragma once
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&quot;point.h&quot;
using namespace std;

class Circle       //圆类
{
public:
    //设置圆心坐标        //只保留函数声明和成员声明
    void set_c_p(Point p);
    //获取圆心
    Point get_c_p();
    //设置半径
    void set_r(int r);
    //获取半径
    int get_r();

private:
    Point c_p; //圆心坐标
    int c_r;    //半径

};



//circle.cpp

#include &quot;circle.h&quot;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;


//设置圆心坐标
void Circle::set_c_p(Point p)     //函数作用域 Circle类下
{
    c_p = p;
}
//获取圆心
Point Circle::get_c_p()
{

    return c_p;
}
//设置半径
void Circle::set_r(int r)
{
    c_r = r;
}
//获取半径
int Circle::get_r()
{
    return c_r;
}



//point.h

#pragma once
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Point
{
public:
    //设置点x坐标
    void set_p_x(int x);
    //设置点y坐标
    void set_p_y(int y);
    //获取点x坐标
    int get_p_x();
    //获取点y坐标
    int get_p_y();

private:
    int p_x;   //点x坐标
    int p_y;   //点y坐标
};



//point.cpp

#include &quot;point.h&quot;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;


//设置点x坐标
void Point::set_p_x(int x)
{
    p_x = x;
}
//设置点y坐标
void Point::set_p_y(int y)
{
    p_y = y;
}
//获取点x坐标
int Point::get_p_x()
{
    return p_x;
}
//获取点y坐标
int Point::get_p_y()
{
    return p_y;
}



//主程序

#include&lt;iostream&gt;
#include&lt;string&gt;
#include&quot;circle.h&quot;
#include&quot;point.h&quot;
using namespace std;

//全局函数确定点和圆的位置关系
void panduan(Circle&amp; c, Point&amp; p)
{
    int c_x = c.get_c_p().get_p_x();  // 圆心x
    int c_y = c.get_c_p().get_p_y();//圆心y
    int r = c.get_r(); //半径
    int p_x = p.get_p_x();
    int p_y = p.get_p_y();
    int d2 = (c_x - p_x) * (c_x - p_x) + (c_y - p_y) * (c_y - p_y);
    if (d2 == (r*r))
    {
        cout &lt;&lt; &quot;点在圆上&quot; &lt;&lt; endl;
    }
    else if (d2 &lt; (c.get_r() * c.get_r()))
    {
        cout &lt;&lt; &quot;点在圆内&quot; &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; &quot;点在圆外&quot; &lt;&lt; endl;
    }
}
int main()
{

    Point p;   //点
    p.set_p_x(3);
    p.set_p_y(0);

    Circle c;    //圆
    c.set_r(3);
    Point c_p;
    c_p.set_p_x(0);
    c_p.set_p_y(0);
    c.set_c_p(c_p);
    panduan(c, p);
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="构造函数什么时候被调用"><a href="#构造函数什么时候被调用" class="headerlink" title="构造函数什么时候被调用"></a>构造函数什么时候被调用</h4><pre><code>//构造函数调用测试
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Point       //创建一个类，会自动生成 默认构造、默认析构、拷贝构造（值拷贝）三个函数
{
public:     
    Point()
    {
        cout &lt;&lt; &quot;默认构造调用&quot; &lt;&lt; endl;
    }
    Point(int a,int b)       //写了有参构造函数，则编译器不再提供默认构造函数，会提供拷贝构造函数
    {                         //写了拷贝构造函数，则编译器不再提供其他构造函数
        p_x = a;
        p_y = b;
        cout &lt;&lt; &quot;有参构造调用&quot; &lt;&lt; endl;
    }
    Point(const Point&amp; a)
    {
        p_x = a.p_x;
        p_y = a.p_y;
        cout &lt;&lt; &quot;拷贝构造调用&quot; &lt;&lt; endl;
    }
    ~Point()
    {                       //析构函数，将堆区（程序员自己开辟）数据释放
        cout &lt;&lt; &quot;默认析构调用&quot; &lt;&lt; endl;
    }

    int p_x;   //点x坐标
    int p_y;
};

void test()
{
    Point p;      //会调用默认构造
    Point b(0,2);  //调用有参构造
    cout &lt;&lt; &quot;b的横坐标为&quot; &lt;&lt; b.p_x &lt;&lt; endl;
    cout &lt;&lt; &quot;b的纵坐标为&quot; &lt;&lt; b.p_y &lt;&lt; endl;
    Point a(b);   //调用拷贝构造
    cout &lt;&lt; &quot;a的横坐标为&quot; &lt;&lt; a.p_x &lt;&lt; endl;
    cout &lt;&lt; &quot;a的纵坐标为&quot; &lt;&lt; a.p_y &lt;&lt; endl;

}


int main()
{
    test();   //执行完后会调用默认析构



    system(&quot;pause&quot;);
    return 0;
}


/*运行结果为：
默认构造调用
有参构造调用
b的横坐标为0
b的纵坐标为2
拷贝构造调用
a的横坐标为0
a的纵坐标为2
默认析构调用
默认析构调用
默认析构调用
请按任意键继续. . .
*/</code></pre><h4 id="析构函数执行堆区数据的释放"><a href="#析构函数执行堆区数据的释放" class="headerlink" title="析构函数执行堆区数据的释放"></a>析构函数执行堆区数据的释放</h4><pre><code>//构造函数调用测试
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Point      
{
public:     
    Point()
    {
        cout &lt;&lt; &quot;默认构造调用&quot; &lt;&lt; endl;
    }
    Point(int a)
    {
        p_x = a;
        p_y = new int(2);     //创建在堆区，由指针去接收
        cout &lt;&lt; &quot;有参构造调用&quot; &lt;&lt; endl;
    }

    ~Point()
    {
        if (p_y != NULL)    //指针不指向空，则释放堆区数据
        {
            delete p_y;
            p_y = NULL;
        }
        cout &lt;&lt; &quot;默认析构调用&quot; &lt;&lt; endl;
    }

    int p_x;   //点x坐标
    int *p_y;
};

void test()
{
    Point p;      //会调用默认构造
    Point b(0);  //调用有参构造
    cout &lt;&lt; &quot;b的横坐标为&quot; &lt;&lt; b.p_x &lt;&lt; endl;
    cout &lt;&lt; &quot;b的纵坐标为&quot; &lt;&lt; *b.p_y &lt;&lt; endl;

}


int main()
{
    test();   //执行完后会调用默认析构

    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="浅拷贝的问题"><a href="#浅拷贝的问题" class="headerlink" title="浅拷贝的问题"></a>浅拷贝的问题</h4><pre><code>//浅拷贝带来的问题
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Point      
{
public:     
    Point()
    {
        cout &lt;&lt; &quot;默认构造调用&quot; &lt;&lt; endl;
    }
    Point(int a)
    {
        p_x = a;
        p_y = new int(2);     //创建在堆区
        cout &lt;&lt; &quot;有参构造调用&quot; &lt;&lt; endl;
    }
    Point(const Point&amp; a)
    {
        p_x = a.p_x;
        p_y = a.p_y;       //指向同一块堆区内存
        cout &lt;&lt; &quot;拷贝构造调用&quot; &lt;&lt; endl;
    }
    ~Point()
    {
        if (p_y != NULL)
        {
            delete p_y;
            p_y = NULL;
        }
        cout &lt;&lt; &quot;默认析构调用&quot; &lt;&lt; endl;
    }

    int p_x;   //点x坐标
    int *p_y;
};

void test()
{
    Point p;      //会调用默认构造
    Point b(0);  //调用有参构造
    cout &lt;&lt; &quot;b的横坐标为&quot; &lt;&lt; b.p_x &lt;&lt; endl;
    cout &lt;&lt; &quot;b的纵坐标为&quot; &lt;&lt; *b.p_y &lt;&lt; endl;
    Point a(b);          //浅拷贝
    cout &lt;&lt; &quot;a的横坐标为&quot; &lt;&lt; a.p_x &lt;&lt; endl;
    cout &lt;&lt; &quot;a的纵坐标为&quot; &lt;&lt; *a.p_y &lt;&lt; endl;     
    //Point a 后定义，但是先被释放，执行析构函数，堆区数据被释放；同样b也会执行相同操作，同一块内存被释放两次，引起错误
}


int main()
{
    test();   //执行完后会调用默认析构



    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="深拷贝解决堆区重复释放的问题"><a href="#深拷贝解决堆区重复释放的问题" class="headerlink" title="深拷贝解决堆区重复释放的问题"></a>深拷贝解决堆区重复释放的问题</h4><pre><code>//深拷贝测试
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Point      
{
public:     
    Point()
    {
        cout &lt;&lt; &quot;默认构造调用&quot; &lt;&lt; endl;
    }
    Point(int a)         //有参构造
    {
        p_x = a;
        p_y = new int(2);     //创建在堆区
        cout &lt;&lt; &quot;有参构造调用&quot; &lt;&lt; endl;
    }
    Point(const Point&amp; a)
    {
        p_x = a.p_x;
        //编译器默认的浅拷贝 p_y = a.p_y;
        p_y = new int(*a.p_y);     //指针解引用，重新开辟堆区内存——深拷贝
        cout &lt;&lt; &quot;拷贝构造调用&quot; &lt;&lt; endl;
    }
    ~Point()
    {
        if (p_y != NULL)
        {
            delete p_y;
            p_y = NULL;
        }
        cout &lt;&lt; &quot;默认析构调用&quot; &lt;&lt; endl;
    }

    int p_x;   //点x坐标
    int *p_y;
};

void test()
{
    Point p;      //会调用默认构造
    Point b(0);  //调用有参构造
    cout &lt;&lt; &quot;b的横坐标为&quot; &lt;&lt; b.p_x &lt;&lt; endl;
    cout &lt;&lt; &quot;b的纵坐标为&quot; &lt;&lt; *b.p_y &lt;&lt; endl;
    Point a(b);
    cout &lt;&lt; &quot;a的横坐标为&quot; &lt;&lt; a.p_x &lt;&lt; endl;
    cout &lt;&lt; &quot;a的纵坐标为&quot; &lt;&lt; *a.p_y &lt;&lt; endl;    //执行各自的析构函数，不再报错
}


int main()
{
    test();   //执行完后会调用默认析构



    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><pre><code>//通过初始化列表给类属性赋值
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Phone
{

public:
    Phone(string name)     //有参构造
    {
        p_name = name;
    }

    string p_name;
};

class Student
{
public:
    Student(string name,int age,Phone phone):s_name(name),s_age(age),s_phone(phone)     //初始化列表
    {

    }

    string s_name;
    int s_age;
    Phone s_phone;     //类的嵌套（一个类作为另一个类的成员变量）
};
void test()
{
    Phone p(&quot;SAMSUNG&quot;);    
    Student s(&quot;张三&quot;, 18, p);
    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; s.s_name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; s.s_age &lt;&lt; &quot; 手机品牌:&quot; &lt;&lt; s.s_phone.p_name &lt;&lt; endl;
}


int main()
{

    test();

    system(&quot;pause&quot;);
    return 0;
}
//构造时，先构造Phone（内层），再构造Student（外层）,析构的顺序与之相反</code></pre><h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><p>1、所有对象共享同一份数据</p>
<p>2、编译阶段就分配内存</p>
<p>3、类内声明，内外初始化</p>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><p>1、通过对象来访问</p>
<p>2、通过类名来访问</p>
<p>3、只能访问静态成员变量</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Point
{
public:
    static void function()
    {
        cout &lt;&lt; &quot;lalall&quot; &lt;&lt; endl;
        a = 100;    //静态成员函数只能访问静态成员变量   非静态成员函数、静态成员函数和静态成员变量，不属于类的对象上，大家共享一份（只有非静态成员变量属于类的对象上）
    }
    static int a;
};
int Point::a = 0;         //静态成员变量，类内声明，类外初始化

void test()
{
    Point p;
    p.function();     //通过对象访问
    Point::function();  //通过类名访问，只有静态成员函数可以，是所有对象共享一份成员函数的体现
}


int main()
{
    test();   //执行完后会调用默认析构



    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="只有非静态成员变量属于类的对象上"><a href="#只有非静态成员变量属于类的对象上" class="headerlink" title="只有非静态成员变量属于类的对象上"></a>只有非静态成员变量属于类的对象上</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Point
{
    int a;
    int b;
};

void test()
{
    Point p;
    cout &lt;&lt; sizeof(p) &lt;&lt; endl;        //8
}


int main()
{
    test();   //执行完后会调用默认析构



    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="成员变量和形参名称冲突-this指针"><a href="#成员变量和形参名称冲突-this指针" class="headerlink" title="成员变量和形参名称冲突   this指针"></a>成员变量和形参名称冲突   this指针</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Point
{
public:
    Point(int a)
    {
        a = a;  //和成员变量a无关  ，修改方式：1、改名称  2、this-&gt;a=a;    this指针指向成员函数被调用的对象（该处为p）
        //cout &lt;&lt; a &lt;&lt; endl;
    }

    int a;
};

void test()
{
    Point p(2);
    cout &lt;&lt; p.a &lt;&lt; endl;    //乱码
}


int main()
{
    test();   //执行完后会调用默认析构



    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="this返回该对象"><a href="#this返回该对象" class="headerlink" title="*this返回该对象"></a>*this返回该对象</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Point
{
public:
    Point(int a)
    {
        this-&gt;a = a; 
    }
    Point&amp; ptop(Point&amp; p)     //返回类的引用，    如果返回值的话（Point），会新创建类，不再是p2
    {
        this-&gt;a += p.a;
        return *this;
    }    

    int a;
};

void test1()
{
    Point p1(10);
    Point p2(10);
    p2.ptop(p1).ptop(p1).ptop(p1);    //链式编程
    cout &lt;&lt; p2.a &lt;&lt; endl;
}
int main()
{
    test1();
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="this-指针本质是指针常量"><a href="#this-指针本质是指针常量" class="headerlink" title="this 指针本质是指针常量"></a>this 指针本质是指针常量</h4><p>P *const this  即this是指向P的一个指针常量</p>
<pre><code>//指针常量 int * const p = &amp;a;  p=&amp;b表达式是错误的，*p = 20是允许的 故：
//P *const this  即this是指向P的一个指针常量
class P
{
public:
    P(int a)
    {
        this-&gt;m_a=a;    //指针常量所指向的内存地址的值是可以修改的
        //this =NULL;  //所指向的内存地址是不允许修改的
    }

    int m_a;
};</code></pre><h4 id="成员函数后加const-常函数"><a href="#成员函数后加const-常函数" class="headerlink" title="成员函数后加const 常函数"></a>成员函数后加const 常函数</h4><pre><code>class Point
{
public:
    void print_a(int a) const      //常函数，const修饰this指针，this指向内存的值不允许修改
    {
        //this-&gt;m_a = a; 
        this -&gt;m_b = 100;     //允许，mutable定义特殊变量，允许修改
        cout &lt;&lt; m_a &lt;&lt; endl;
    }

    int m_a;
    mutable int m_b;
};

void test()
{
    const Point p;    //常对象    常对象只能调用常函数，不能调用普通的成员函数
    //p.m_a = 100;   不允许修改
    p.m_b=100;   //允许
}

int main()
{
    test();

    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="构造和析构函数上不允许使用类型限定符（如const）"><a href="#构造和析构函数上不允许使用类型限定符（如const）" class="headerlink" title="构造和析构函数上不允许使用类型限定符（如const）"></a>构造和析构函数上不允许使用类型限定符（如const）</h4><h4 id="友元（可以访问类中的私有成员）"><a href="#友元（可以访问类中的私有成员）" class="headerlink" title="友元（可以访问类中的私有成员）"></a>友元（可以访问类中的私有成员）</h4><h5 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h5><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Building
{
    friend void test(Building* building);   //全局函数做友元，可以访问私有成员
public:
    Building()
    {
        m_s = &quot;啦啦啦啦&quot;;
        m_b = &quot;不不不不不不&quot;;
    }

    string m_s;
private:
    string m_b;
};
void test(Building* building)
{
    string a = building-&gt;m_s;
    cout &lt;&lt; a &lt;&lt; endl;
    string b = building-&gt;m_b;
    cout &lt;&lt; b &lt;&lt; endl;
}

int  main()
{
    Building building;    //默认构造
    test(&amp;building);

    system(&quot;pause&quot;);
    return 0;
}</code></pre><h5 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h5><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Building
{
    friend class goodguy;   //goodguy类做友元
public:
    Building();
    string m_s;
private:
    string m_b;
};

class goodguy
{
public:
    void visit();
    Building building;   //类的嵌套
};

Building::Building()     //类外写成员函数（构造函数）
{
    m_s = &quot;lallalal&quot;;
    m_b = &quot;bbbbbbb&quot;;
}

void goodguy::visit()
{
    cout &lt;&lt; building.m_s &lt;&lt; endl;
    cout &lt;&lt; building.m_b &lt;&lt; endl;
}
int  main()
{
    goodguy guy;
    guy.visit();
    system(&quot;pause&quot;);
    return 0;
}



//不用类的嵌套
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;


class Building
{
    friend class goodguy; //类做友元
public:
    Building();  //构造函数声明，类外实现
    string m_s;
private:
    string m_b;
};

class goodguy
{
public:
    goodguy();
    void visit();

    Building* building; //指针
};

Building::Building()
{
    m_s = &quot;lallalal&quot;;
    m_b = &quot;bbbbbbb&quot;;
}
goodguy::goodguy()      //构造函数实现
{

    building  = new Building;     //堆区开辟一个Building，赋给指针building
}
void goodguy::visit()
{
    cout &lt;&lt; building-&gt;m_s &lt;&lt; endl;
    cout &lt;&lt; building-&gt;m_b &lt;&lt; endl;
}
int  main()
{

    goodguy guy;
    guy.visit();
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h5 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h5><pre><code>//（类中的某个成员函数做友元）
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Building;
class goodguy        //要把该类写在Building类前面，否则第x行还是会报错
{
public:
    goodguy();
    void visit();
    void visit2();
    Building* building;
};
class Building
{
    friend void goodguy::visit();
public:
    Building();
    string m_s;
private:
    string m_b;
};

Building::Building()
{
    m_s = &quot;lallalal&quot;;
    m_b = &quot;bbbbbbb&quot;;
}
goodguy::goodguy()
{

    building  = new Building;
}
void goodguy::visit()
{
    cout &lt;&lt; building-&gt;m_s &lt;&lt; endl;
    cout &lt;&lt; building-&gt;m_b &lt;&lt; endl;    //第x行
}
void goodguy::visit2()
{
    cout &lt;&lt; building-&gt;m_s &lt;&lt; endl;
}
int  main()
{
    goodguy guy;
    guy.visit();
    guy.visit2();
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="运算符重载（加法）"><a href="#运算符重载（加法）" class="headerlink" title="运算符重载（加法）"></a>运算符重载（加法）</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Person
{
public:
    Person operator+(Person&amp; a);         //重载运算符-也是类似
    int m_a;
    int m_b;

};

Person Person::operator+(Person&amp; a)      //成员函数重载+号
{
    Person c;
    c.m_a = this-&gt;m_a + a.m_a;
    c.m_b = this-&gt;m_b + a.m_b;
    return c;
}
//Person operator+(Person&amp; a, Person&amp; b)   //全局函数重载+号
//{
//    Person c;
//    c.m_a = a.m_a + b.m_a;
//    c.m_b = a.m_b + b.m_b;
//    return c;
//}

Person operator+(Person &amp;a,int b)      //函数重载，函数名相同，但是参数不同
{
    Person c;
    c.m_a = a.m_a + b;
    c.m_b = a.m_b + b;
    return c;
}
void test()
{
    Person a;
    a.m_a = 10;
    a.m_b = 20;

    Person b;
    b.m_a = 10;
    b.m_b = 20;
    Person c = a + b;     //本质上是     Person c = a.operator+(b);      Person c = operator+(a,b)
    cout &lt;&lt; c.m_a &lt;&lt; endl;
    cout &lt;&lt; c.m_b &lt;&lt; endl;

    Person d = a+10;      //Person + int
    cout&lt;&lt;d.m_a&lt;&lt;endl;     //20
    cout&lt;&lt;d.m_b&lt;&lt;endl;     //30
}
int  main()
{
    test();
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="运算符重载（左移运算符）"><a href="#运算符重载（左移运算符）" class="headerlink" title="运算符重载（左移运算符）"></a>运算符重载（左移运算符）</h4><pre><code>//（直接输出类的成员变量的值）
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Person
{
public:
    Person(int a, int b)     //有参构造函数可以解决私有成员访问问题
    {
        m_a = a;
        m_b = b;
    }
    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person a);

private:
    int m_a;
    int m_b;

};

ostream&amp; operator&lt;&lt;(ostream &amp;cout, Person a)    //cout 数据类型为标准输出流ostream,且cout唯一所以要用引用
{
    cout &lt;&lt; a.m_a &lt;&lt; &quot; &quot; &lt;&lt; a.m_b;
    return cout;
}
void test()
{
    Person a(10, 20);
    cout &lt;&lt; a &lt;&lt; endl;    //本质上是operator&lt;&lt;(cout,a)
}
int  main()
{
    test();
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="编译器默认提供的类的函数"><a href="#编译器默认提供的类的函数" class="headerlink" title="编译器默认提供的类的函数"></a>编译器默认提供的类的函数</h4><p>1、默认构造</p>
<p>2、默认析构</p>
<p>3、拷贝构造</p>
<p>4、赋值运算符 operator=，（类可以直接进行赋值运算）</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Person
{
public:
    Person(int age)
    {
        m_age = new int(age);   //将age数据开辟到堆区
    }
    int* m_age;
};

void test()
{
    Person p1(18);
    cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_age &lt;&lt; endl;
    Person p2(20);
    p2 = p1;    //直接进行赋值运算
    cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_age &lt;&lt; endl;

}
int  main()
{
    test();
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="运算符重载（赋值运算）"><a href="#运算符重载（赋值运算）" class="headerlink" title="运算符重载（赋值运算）"></a>运算符重载（赋值运算）</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Person
{
public:
    Person(int age)
    {
        m_age = new int(age);   //将age数据开辟到堆区
    }

    Person&amp; operator=(Person&amp; a)
    {
        if (m_age != NULL)
        {
            delete m_age;
            m_age = NULL;
        }
        this-&gt;m_age = new int(*a.m_age);    //深拷贝，解决堆区重复释放的问题，返回Person的引用是为了连续赋值
        return *this;
    }
    int* m_age;
};


void test()
{
    Person p1(18);
    cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_age &lt;&lt; endl;
    Person p2(20);
    Person p3(30);
    p3 =p2 = p1;    //直接进行赋值运算
    cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_age &lt;&lt; endl;
    cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_age &lt;&lt; endl;

}
int  main()
{
    test();
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>class 子类 : 继承方式 父类</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class basepage
{
public:
    void header()
    {
        cout &lt;&lt; &quot;aaaaaa&quot; &lt;&lt; endl;
    }
    void footer()
    {
        cout &lt;&lt; &quot;bbbbbb&quot; &lt;&lt; endl;
    }
    void left()
    {
        cout &lt;&lt; &quot;ccccccc&quot; &lt;&lt; endl;
    }
    void right()
    {
        cout &lt;&lt; &quot;dddddddd&quot; &lt;&lt; endl;
    }
};

class java:public basepage
{
public:
    void content()
    {
        cout &lt;&lt; &quot;this is java&quot; &lt;&lt; endl;
    }
};
void test()
{
    java ja;
    ja.header();
    ja.footer();
    ja.left();
    ja.right();
    ja.content();
}

int  main()
{
    test();
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><p>父类中的private，子类不可访问</p>
<p>1、公共继承</p>
<p>class 子类 : public 父类</p>
<p>public——public</p>
<p>protected—— protected</p>
<p>2、保护继承</p>
<p>class 子类 : protected 父类</p>
<p>public、protected——protected</p>
<p>3、私有继承</p>
<p>class 子类 : private 父类</p>
<p>public、protected——private</p>
<h4 id="利用开发人员命令提示工具查看对象模型"><a href="#利用开发人员命令提示工具查看对象模型" class="headerlink" title="利用开发人员命令提示工具查看对象模型"></a>利用开发人员命令提示工具查看对象模型</h4><pre><code>C:\Users\xx\source\repos\Project1\Project1&gt;cl /d1 reportSingleClassLayoutbasepage 源.cpp
//C:\Users\xx\source\repos\Project1\Project1&gt;为cpp文件所在路径 basepage为类名</code></pre><h4 id="子类中同名属性的访问"><a href="#子类中同名属性的访问" class="headerlink" title="子类中同名属性的访问"></a>子类中同名属性的访问</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class base
{
public:
    base()
    {
        m_a = 100;
    }
    int m_a;

};

class son :public base
{
public:
    son()
    {
        m_a = 200;
    }
    int m_a ;
};

void test()
{
    son s;
    cout &lt;&lt; s.m_a &lt;&lt; endl;     //直接访问为子类的属性
    cout &lt;&lt; s.base::m_a &lt;&lt; endl;   //父类中同名属性访问需要加上作用域

}
int  main()
{
    test();
    system(&quot;pause&quot;);
    return 0;
}



#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class base
{
public:
    base()
    {
        m_a = 100;
    }
    void aaaa()
    {
        m_a = 200;
    }
    void aaaa(int b)
    {
        m_a = 500;
    }
    int m_a;

};

class son :public base
{
public:
    son()
    {
        m_a = 300;
    }
    void aaaa()
    {
        m_a = 400;
    }

    int m_a ;
};

void test()
{
    son s;
    s.aaaa();
    cout &lt;&lt; s.m_a &lt;&lt; endl;    //400
    s.base::aaaa();
    cout &lt;&lt; s.base::m_a &lt;&lt; endl;    //200
    s.base::aaaa(10);          //只要出现同名，父类中的函数都会被隐藏必须加作用域才能访问
    cout &lt;&lt; s.base::m_a &lt;&lt; endl;    //500
}
int  main()
{
    test();
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>class 子类 ：public 父类1，public 父类2……</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class base1
{
public:
    base1()
    {
        m_a = 100;
    }
    int m_a;

};

class base2
{
public:
    base2()
    {
        m_b = 200;
    }
    int m_b;
};
class son :public base1,public base2     //多继承
{
public:
    son()
    {
        m_c = 300;
    }

     int m_c ;
};

void test()
{
    son s;
    cout &lt;&lt; s.m_a &lt;&lt; endl;
    cout &lt;&lt; s.m_b &lt;&lt; endl;
    cout &lt;&lt; s.m_c &lt;&lt; endl;
}
int  main()
{
    test();
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h4 id="父类的引用指向子类的对象"><a href="#父类的引用指向子类的对象" class="headerlink" title="父类的引用指向子类的对象"></a>父类的引用指向子类的对象</h4><pre><code>class Animal
{
public:

    void speak()
    {
        cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;
    }
};

class cat:public Animal
{
public:

    void speak()
    {
        cout &lt;&lt; &quot;猫在说话&quot; &lt;&lt; endl;
    }
};
void dospeak(Animal &amp;animal)      
{
    animal.speak();      //编译的时候提前分配空间，输出一定是“动物在说话”
}

void test()
{
    cat a;
    dospeak(a);      //允许父类的引用指向子类的对象 Animal &amp;animal = cat，不需要做类型转换
}</code></pre><h4 id="动态多态（父类函数前加virtual）"><a href="#动态多态（父类函数前加virtual）" class="headerlink" title="动态多态（父类函数前加virtual）"></a>动态多态（父类函数前加virtual）</h4><p>满足条件<br>1、有类的继承关系<br>2、子类重写父类的虚函数（函数返回类型、函数名、参数条件都相同）<br>3、全局函数中父类通过指针或引用指向子类对象</p>
<pre><code>class Calculator
{
public:
    virtual int get_result()=0;   
    //纯虚函数
    //有纯虚函数的类称为抽象类
    //1、不能实例化对象；2、子类需重写纯虚函数，否则仍为抽象类
    int a;
    int b;
};       //抽象的计算器类

class ADDCalculator : public Calculator
{
public:
    int get_result()
    {
        int c = this-&gt;a + this-&gt;b;
        return c;
    }
};
class MULCalculator : public Calculator
{
public:
    int get_result()
    {
        int c = this-&gt;a * this-&gt;b;
        return c;
    }
};
class SUBCalculator : public Calculator
{
public:
    int get_result()
    {
        int c = this-&gt;a - this-&gt;b;
        return c;
    }
};
void test()
{
    //多态的两种实现方式
    //1、父类的指针指向子类的对象
    Calculator* abc = new SUBCalculator;   
    abc-&gt;a = 10;
    abc-&gt;b = 20;
    int c = abc-&gt;get_result();
    cout &lt;&lt; c &lt;&lt; endl;
    delete abc;

    //2、父类的引用指向子类的对象
    SUBCalculator A;
    Calculator&amp; cal = A;
    cal.a = 10;
    cal.b = 10;
    int d = cal.get_result();
    cout &lt;&lt; d &lt;&lt; endl;

}</code></pre>
      
       
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>c++学习</p>
    
    <p><span class="copy-title">本文作者:</span><a href="javascript:void(0)" target="_blank" rel="noopener" title="Echo">Echo</a></p>
    <p><span class="copy-title">发布时间:</span>2020-11-17, 22:55:06</p>
    <p><span class="copy-title">最后更新:</span>2020-11-27, 22:34:26</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2020/11/17/c++%E5%AD%A6%E4%B9%A0/" title="c++学习">http://dmzecho.github.io/2020/11/17/c++%E5%AD%A6%E4%B9%A0/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2017 Echo</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" href="javascript:void(0)" target="_blank" rel="noopener"></a>
    </div>
</div>
<div class="acParent"></div>

</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#math',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
