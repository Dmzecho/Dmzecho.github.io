<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器人学</title>
      <link href="2021/07/29/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/"/>
      <url>2021/07/29/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="连杆间速度传递"><a href="#连杆间速度传递" class="headerlink" title="连杆间速度传递"></a>连杆间速度传递</h3><p>参考 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT</title>
      <link href="2021/04/15/QT/"/>
      <url>2021/04/15/QT/</url>
      
        <content type="html"><![CDATA[<h3 id="QT-Creator-快捷键"><a href="#QT-Creator-快捷键" class="headerlink" title="QT Creator 快捷键"></a>QT Creator 快捷键</h3><pre><code>//注释    Ctrl + ///编译    Ctrl + b//运行    Ctrl + r//字体缩放 Ctrl + 鼠标滚轮//查找    Ctrl + f//自动对齐 Ctrl + i//帮助    F1//跳转    F2//同名.cpp和.h文件的切换 F4</code></pre><h3 id="对象树"><a href="#对象树" class="headerlink" title="对象树"></a>对象树</h3><p>  在创建一个对象时，如果指定其父对象，则该对象会自动添加到其父对象的children()列表中。并且其父对象析构时，这个列表中所有子对象都会析构。<br>  故如果对象继承关系为QObject-&gt;QWidget-&gt;myWidget-&gt;创建的所有对象，则不用考虑堆区对象的释放问题，结束时会从子到父依次析构。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++进阶</title>
      <link href="2021/04/14/c++%E8%BF%9B%E9%98%B6/"/>
      <url>2021/04/14/c++%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="std-vector-定义长度可变的数组"><a href="#std-vector-定义长度可变的数组" class="headerlink" title="std::vector 定义长度可变的数组"></a>std::vector 定义长度可变的数组</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><pre><code>std::vector&lt;std::string&gt; str;str.push_back(&quot;ur5e_&quot;);str.push_back(&quot;test1&quot;);for (int i=0;i&lt;str.size();i++){    std::cout&lt;&lt;str[i]&lt;&lt;&quot; &quot;;}std::cout&lt;&lt;std::endl;//str.size() 用于获取数组长度 </code></pre><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><pre><code>std::vector&lt;std::vector&lt;int&gt; &gt; vec(1);   //指定行数vec[0].resize(2);    //指定列数vec[0][0]=2;vec[0][1]=1;for(int i=0;i&lt;vec.size();i++) {    for (int j = 0; j &lt; vec[0].size(); j++) {        std::cout &lt;&lt; vec[i][j] &lt;&lt; &quot; &quot;;    }    std::cout &lt;&lt; std::endl;}</code></pre><h3 id="argc-argv"><a href="#argc-argv" class="headerlink" title="argc,argv"></a>argc,argv</h3><pre><code>int main(int argc, char *argv[]){    //argc 命令行变量的数量，argv命令行变量的数组}</code></pre><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><h4 id="一般函数指针"><a href="#一般函数指针" class="headerlink" title="一般函数指针"></a>一般函数指针</h4><pre><code>#定义一个函数void test(int a){    std::cout&lt;&lt;&quot;a的值为：&quot;&lt;&lt;a&lt;&lt;std::endl;}int main(){    void (*test1)(int) = &amp;test;   //指针test1指向函数test的地址    (*test1)(1);    //test1(1)   也可以}</code></pre><h4 id="类的成员函数指针"><a href="#类的成员函数指针" class="headerlink" title="类的成员函数指针"></a>类的成员函数指针</h4><h5 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h5><pre><code>class shownum{public:    //定义静态成员函数    static void shown(int a)    {        std::cout&lt;&lt;&quot;a的值为：&quot;&lt;&lt;a&lt;&lt;std::endl;    }}int main(){    //类的静态成员函数指针，不指定作用域    void(*test)(int) = &amp;shownum::showm;      (*test)(3);    //test(3);   也可以 }</code></pre><h5 id="一般成员函数"><a href="#一般成员函数" class="headerlink" title="一般成员函数"></a>一般成员函数</h5><pre><code>class shownum{public:    void shown(int a)    {        std::cout&lt;&lt;&quot;a的值为：&quot;&lt;&lt;a&lt;&lt;std::endl;    }}int main(){    void(shownum::*test)(int) = &amp;shownum::showm;     shownum d;     (d.*test)(3);    //调用时*test就相当于shownum::showm    //shownum *d =new shownum;    //(d-&gt;*fun)(55); }</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>conda简单使用</title>
      <link href="2021/04/11/conda%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2021/04/11/conda%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="新建conda环境"><a href="#新建conda环境" class="headerlink" title="新建conda环境"></a>新建conda环境</h3><pre><code>conda create -n 环境名#如果有python版本要求，在末尾跟上，如python=2.7</code></pre><h3 id="激活conda环境"><a href="#激活conda环境" class="headerlink" title="激活conda环境"></a>激活conda环境</h3><pre><code>conda activate 环境名#激活之后会自动进入该环境，为了使用方便，建议在 .bashrc文件中加入快捷方式</code></pre><h3 id="向环境中添加包"><a href="#向环境中添加包" class="headerlink" title="向环境中添加包"></a>向环境中添加包</h3><pre><code>conda install 包名#与pip install 效果一样</code></pre><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><pre><code>conda info -e#查看所有的虚拟环境conda install tensorflow-gpu==1.5.0#指定安装包的版本conda deactivate#退出整个conda环境</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Matlab学习</title>
      <link href="2020/12/15/Matlab%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/12/15/Matlab%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Matlab学习"><a href="#Matlab学习" class="headerlink" title="Matlab学习"></a>Matlab学习</h1><h4 id="坐标轴设置"><a href="#坐标轴设置" class="headerlink" title="坐标轴设置"></a>坐标轴设置</h4><pre><code>axis([-0.6,0.6,-0.5,0.5])          #设置坐标轴显示范围set(gca,&apos;xtick&apos;,-0.6:0.2:0.6)      #坐标轴标注范围和间隔set(gca,&apos;ytick&apos;,-0.5:0.1:0.5)axis equal                         #使x,y轴的单位长度相同axis square                        #出图为正方形xlabel(&apos;x&apos;)ylabel(&apos;y&apos;)</code></pre><h4 id="矩阵定义"><a href="#矩阵定义" class="headerlink" title="矩阵定义"></a>矩阵定义</h4><p>a、矩阵元素必须在”[ ]”内；<br>b、矩阵的同行元素之间用空格或逗号隔开；<br>c、矩阵的行与行之间用”;”（或回车符）隔开；<br>d、矩阵的元素可以是数值、变量、表达式或函数；<br>e、矩阵的尺寸不必预先定义。</p><pre><code>a=[[1,2,3];[3,2,1]]a=[1,2,3;3,2,1]</code></pre><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><pre><code>spline  #三次样条数据插值，yy = spline(x,y,xx)，返回在xx处的函数值yy#即已知x上若干离散点对应的y中的值，用三次样条曲线插值，得到xx中点的值，xx一般为linspace()repmat  #矩阵平铺，repmat([1,2;3,4],2,3),得到一个4×6的矩阵</code></pre><h4 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h4><pre><code>plot3(rDataj(1,:), rDataj(2,:),rDataj(3,:), &apos;-&apos;,&apos;lineWidth&apos;,2,&apos;color&apos;,[0 .8 0])#指定线宽和颜色</code></pre><h4 id="论文中matlab标准画图"><a href="#论文中matlab标准画图" class="headerlink" title="论文中matlab标准画图"></a>论文中matlab标准画图</h4><pre><code>width = 240;   % 240pt  US letter 双栏 1pt = 1/72inch   1 inch = 25.4mmxlabel(&apos;\fontname{宋体}力模长\fontname{Times New Roman}(N)&apos;,&apos;Fontname&apos;, &apos;Times New Roman&apos;);#xlabel(&apos;Torque $M_x$ (Nm)&apos;,&apos;interpreter&apos;,&apos;latex&apos;,&apos;FontSize&apos;,8); % Latex格式的labelylabel(&apos;\fontname{宋体}概率&apos;,&apos;Fontname&apos;, &apos;Times New Roman&apos;);#设置坐标轴标识set(gca, &apos;Fontsize&apos;, 8);   #坐标轴句柄，设置坐标轴刻度数字样式set(gca, &apos;XTick&apos;,0:4:20);  #设置X轴刻度L1 = legend([P1 P2 P3],&apos;高斯分布&apos;,&apos;均值&apos;,&apos;阈值&apos;);set(L1,&apos;Location&apos;,&apos;northeast&apos;,&apos;Orientation&apos;,&apos;vertical&apos;,...    &apos;Fontname&apos;, &apos;宋体&apos;,&apos;FontSize&apos;,8,&apos;TextColor&apos;,&apos;black&apos;);#legend 格式  print(&apos;S:\PbD\graph\Force_threhold_change&apos;,&apos;-djpeg&apos;,&apos;-r600&apos;);#输出#例子width = 240;set(gcf,&apos;unit&apos;,&apos;points&apos;,&apos;PaperUnits&apos;,&apos;points&apos;,&apos;PaperPosition&apos;,[0,0,width,width/5*4],...    &apos;position&apos;,[500 300 width width/5*4],&apos;color&apos;,&apos;w&apos;,&apos;PaperSize&apos;,[width, width/5*4]);..........plot(Data(1,(n-1)*nbData+1:n*nbData), Data(m+1,(n-1)*nbData+1:n*nbData), &apos;-&apos;,&apos;lineWidth&apos;,1.2)   #设置线宽，最好是用变量表示，方便修改set(gca,&apos;xtick&apos;,1:1:10,&apos;Fontname&apos;,&apos;Times New Roman&apos;,&apos;FontSize&apos;,8);set(gca,&apos;ytick&apos;,-550:50:-50,&apos;Fontname&apos;,&apos;Times New Roman&apos;,&apos;FontSize&apos;,8);   #坐标轴刻度xlabel(&apos;t(s)&apos;,&apos;Fontname&apos;,&apos;Times New Roman&apos;,&apos;FontSize&apos;,8);ylabel(&apos;ave-EMG(mv)&apos;,&apos;Fontname&apos;,&apos;Times New Roman&apos;,&apos;FontSize&apos;,8);     #坐标轴标识</code></pre><h4 id="ndgrid-生成网格"><a href="#ndgrid-生成网格" class="headerlink" title="ndgrid 生成网格"></a>ndgrid 生成网格</h4><pre><code>nbGrid = 30; rg = linspace(-3.5,3.5,nbGrid);         #Grid range[xm, ym] = ndgrid(rg,rg);     #size(xm)=30,30 xg = [xm(:)&apos;; ym(:)&apos;];        #Grid datapoints   size(xg)=2,900#size(xm(:)&apos;)=1,900  ,即将xm展成一行，类似于python中 np.reshape(1,-1)</code></pre><h4 id="size-返回矩阵的维度"><a href="#size-返回矩阵的维度" class="headerlink" title="size 返回矩阵的维度"></a>size 返回矩阵的维度</h4><pre><code>size(a) #返回矩阵a的行数和列数size(a，1)  #返回行数size(a，2)  #返回列数</code></pre><h4 id="sum-求元素的和"><a href="#sum-求元素的和" class="headerlink" title="sum 求元素的和"></a>sum 求元素的和</h4><pre><code>a=[[1,2,3,4];[2,3,4,5]]；b=sum(a);   #默认是按列求和，即保持列数不变# b=[3,5,7,9]c=sum(a,1)c=[3,5,7,9]d=sum(a,2)d=[10;14]</code></pre><h4 id="fmincon"><a href="#fmincon" class="headerlink" title="fmincon"></a>fmincon</h4><pre><code># fmincon是用于求解非线性多元函数最小值的matlab函数，优化工具箱提供fmincon函数用于对有约束优化问题进行求解x= fmincon(fun,x0,A,b) #给定初值x0，求解fun函数的最小值x。fun函数的约束条件为A*x&lt;= b，x0可以是标量或向量x= fmincon(fun,x0,A,b,Aeq,beq) #约束条件为Aeq*x= beq 和 A*x &lt;= b。若没有不等式线性约束存在，则设置A=[]、b=[]x= fmincon(fun,x0,A,b,Aeq,beq,lb,ub) #定义设计变量x的线性不等式约束下界lb和上界ub，使得总是有lb&lt;= x &lt;= ub#若无等式线性约束存在，则令Aeq=[]、beq=[]options = optimoptions(&apos;fmincon&apos;,&apos;Display&apos;,&apos;off&apos;);    #创建优化选项x= fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options);#给定初值x0，求解fun函数的最小值x,A 和 Aeq 为线性不等式约束和等式约束的系数矩阵#A*x&lt;= b,Aeq*x= beq,lb&lt;= x &lt;= ub#在nonlcon参数中提供非线性不等式c(x)或等式ceq(x),fmincon函数要求c(x) &lt;= 0且ceq(x)= 0#用options参数指定的参数进行最小化## 简单应用func = @(x)3*x^2+4*x+5;options = optimoptions(&apos;fmincon&apos;,&apos;Display&apos;,&apos;off&apos;);[a,b]=fmincon(func,-4,[],[],[],[],-7,10,[],options);# 得到 a=-0.6667,b=3.6667</code></pre><h4 id="solve-解方程（组）"><a href="#solve-解方程（组）" class="headerlink" title="solve 解方程（组）"></a>solve 解方程（组）</h4><pre><code># 解方程syms x；    #定义x为符号变量eq=x^2+2*x+1;s=solve(eq,x);# 解方程组syms x,y;eq1 = x+2*y-8;eq2 = 3*x+5*y-4;s=solve(eq1,eq2,x,y);# 得到 s.x =-32,   s.y=20</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>四元数</title>
      <link href="2020/11/24/%E5%9B%9B%E5%85%83%E6%95%B0/"/>
      <url>2020/11/24/%E5%9B%9B%E5%85%83%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="四元数与旋转矩阵"><a href="#四元数与旋转矩阵" class="headerlink" title="四元数与旋转矩阵"></a>四元数与旋转矩阵</h1><p>部分摘自 <a href="https://krasjet.github.io/quaternion/quaternion.pdf" target="_blank" rel="noopener">https://krasjet.github.io/quaternion/quaternion.pdf</a><br>        里面对四元数和3D旋转的关系以及四元数乘法运算讲得很详细</p><p>四元数的介绍视频 <a href="https://www.bilibili.com/video/BV1SW411y7W1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1SW411y7W1</a><br><a href="https://www.bilibili.com/video/BV1Lt411U7og" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Lt411U7og</a></p><h3 id="四元数乘法python"><a href="#四元数乘法python" class="headerlink" title="四元数乘法python"></a>四元数乘法python</h3><pre><code>import numpy as npdef qua_multi(qa,qb,m):        #qa,qb均为四元数,[x,y,z,w],实轴在最后    if(m==0):        #qb左乘qa        qa_m=[[qa[3],-qa[2],qa[1],qa[0]],        [qa[2],qa[3],-qa[0],qa[1]],        [-qa[1],qa[0],qa[3],qa[2]],        [-qa[0],-qa[1],-qa[2],qa[3]]]           qc=np.matmul(qa_m,qb)    if(m==1):              #qb右乘qa        qa_m=[[qa[3],qa[2],-qa[1],qa[0]],        [-qa[2],qa[3],qa[0],qa[1]],        [qa[1],-qa[0],qa[3],qa[2]],        [-qa[0],-qa[1],-qa[2],qa[3]]]        qc=np.matmul(qa_m,qb)    return qc</code></pre><h3 id="已知末端姿态的四元数表示，求末端z轴的向量表示"><a href="#已知末端姿态的四元数表示，求末端z轴的向量表示" class="headerlink" title="已知末端姿态的四元数表示，求末端z轴的向量表示"></a>已知末端姿态的四元数表示，求末端z轴的向量表示</h3><pre><code>#设姿态为q0(x,y,z,w),思路是[0,0,1]左乘q0,右乘q0的逆q1=[0,0,1,0]q2=qua_multi(q0,q1,0)     #q1左乘q0q0_0=[-q0[0],-q0[1],-q0[2],q0[3]]q3=qua_multi(q0_0,q2,1)    #右乘q0的逆，前提是将q0转化成单位四元数，否则求逆时还要在共轭的基础上除以模长的平方</code></pre><h3 id="已知末端姿态，求绕z轴旋转120度的新姿态"><a href="#已知末端姿态，求绕z轴旋转120度的新姿态" class="headerlink" title="已知末端姿态，求绕z轴旋转120度的新姿态"></a>已知末端姿态，求绕z轴旋转120度的新姿态</h3><pre><code>末端姿态四元数均是在基座标系下的表示，而z轴是动系的坐标轴</code></pre><h4 id="思路1-通过齐次旋转矩阵间接转化"><a href="#思路1-通过齐次旋转矩阵间接转化" class="headerlink" title="思路1 通过齐次旋转矩阵间接转化"></a>思路1 通过齐次旋转矩阵间接转化</h4><pre><code>def matrix_from_quaternion(quaternion, pos=None):        #由四元数返回齐次旋转矩阵    q = np.array(quaternion, dtype=np.float64, copy=True)    q = q[[3, 0, 1, 2]]    if pos is None: pos = np.zeros(3)    n = np.dot(q, q)    if n &lt; 1e-20:        return np.identity(4)    q *= np.sqrt(2.0 / n)    q = np.outer(q, q)    return np.array([        [1.0 - q[2, 2] - q[3, 3], q[1, 2] - q[3, 0], q[1, 3] + q[2, 0], pos[0]],        [q[1, 2] + q[3, 0], 1.0 - q[1, 1] - q[3, 3], q[2, 3] - q[1, 0], pos[1]],        [q[1, 3] - q[2, 0], q[2, 3] + q[1, 0], 1.0 - q[1, 1] - q[2, 2], pos[2]],        [0.0, 0.0, 0.0, 1.0]])def quaternion_from_matrix(matrix, isprecise=False):    #旋转矩阵转四元数    &quot;&quot;&quot;    LAYOUT : [X, Y, Z, W]    If isprecise is True, the input matrix is assumed to be a precise rotation    matrix and a faster algorithm is used.    &quot;&quot;&quot;    M = np.array(matrix, dtype=np.float64, copy=False)[:4, :4]    if isprecise:        q = np.empty((4,))        t = np.trace(M)        if t &gt; M[3, 3]:            q[0] = t            q[3] = M[1, 0] - M[0, 1]            q[2] = M[0, 2] - M[2, 0]            q[1] = M[2, 1] - M[1, 2]        else:            i, j, k = 1, 2, 3            if M[1, 1] &gt; M[0, 0]:                i, j, k = 2, 3, 1            if M[2, 2] &gt; M[i, i]:                i, j, k = 3, 1, 2            t = M[i, i] - (M[j, j] + M[k, k]) + M[3, 3]            q[i] = t            q[j] = M[i, j] + M[j, i]            q[k] = M[k, i] + M[i, k]            q[3] = M[k, j] - M[j, k]        q *= 0.5 / np.sqrt(t * M[3, 3])    else:        m00 = M[0, 0]        m01 = M[0, 1]        m02 = M[0, 2]        m10 = M[1, 0]        m11 = M[1, 1]        m12 = M[1, 2]        m20 = M[2, 0]        m21 = M[2, 1]        m22 = M[2, 2]        # symmetric matrix K        K = np.array([[m00 - m11 - m22, 0.0, 0.0, 0.0],                    [m01 + m10, m11 - m00 - m22, 0.0, 0.0],                    [m02 + m20, m12 + m21, m22 - m00 - m11, 0.0],                    [m21 - m12, m02 - m20, m10 - m01, m00 + m11 + m22]])        K /= 3.0        # quaternion is eigenvector of K that corresponds to largest eigenvalue        w, V = np.linalg.eigh(K)  #特征值和特征向量        q = V[:, np.argmax(w)]        if q[0] &lt; 0.0:            np.negative(q, q)    return qdef go_to_orien(a):     #a为旋转的角度，q0为现在的姿态（四元数[x,y,z,w]）    q0_now= quaternion.matrix_from_quaternion(q0)    #将现在姿态四元数转换成旋转矩阵    matri_qd=[[math.cos(a*math.pi/180),-math.sin(a*math.pi/180),0,0],[math.sin(a*math.pi/180),math.cos(a*math.pi/180),0,0],[0,0,1,0],[0,0,0,1]]     #由给定角度计算齐次旋转矩阵    qd_m= np.matmul(q0_now, matri_qd)     #绕动系坐标轴旋转，右乘    qd = quaternion.quaternion_from_matrix(qd_m)   #得到目标姿态四元数</code></pre><h4 id="思路二-四元数乘法直接计算"><a href="#思路二-四元数乘法直接计算" class="headerlink" title="思路二 四元数乘法直接计算"></a>思路二 四元数乘法直接计算</h4><pre><code>def go_to_orien_test(a):     #a为旋转的角度，q0为现在的姿态（四元数[x,y,z,w]）    q1=[0,0,1,0]    q0=x0[3:]    q2=qua_multi(q0,q1,0)    q0_0=[-q0[0],-q0[1],-q0[2],q0[3]]    q3=qua_multi(q0_0,q2,1)    #得到现在的z轴在基座标系下的四元数表示[i,j,k,0]    q1= np.empty((4,))    q1[0]=math.sin(a*math.pi/180/2)*q3[0]    q1[1]=math.sin(a*math.pi/180/2)*q3[1]    q1[2]=math.sin(a*math.pi/180/2)*q3[2]    q1[3]=math.cos(a*math.pi/180/2)               #绕z轴旋转a度的四元数表示 cos(theta/2)+sin(theta/2)(b*i+c*j+d*k)    qd=qua_multi(q1,q0,0)       #只用左乘q1即可得到新的姿态四元数，一个点左乘q右乘q逆是得到点新的坐标（一定是纯四元数）</code></pre><h3 id="四元数计算公式"><a href="#四元数计算公式" class="headerlink" title="四元数计算公式"></a>四元数计算公式</h3><h4 id="四元数乘法"><a href="#四元数乘法" class="headerlink" title="四元数乘法"></a>四元数乘法</h4><p>$$<br>q_{1}=a+b i+c j+d k, \quad q_{2}=e+f i+g j+h k<br>$$<br>q2左乘q1<br>$$<br>q_{1} q_{2}=\left[\begin{array}{cccc}<br>a &amp; -b &amp; -c &amp; -d \\<br>b &amp; a &amp; -d &amp; c \\<br>c &amp; d &amp; a &amp; -b \\<br>d &amp; -c &amp; b &amp; a<br>\end{array}\right]\left[\begin{array}{l}<br>e \\<br>f \\<br>g \\<br>h<br>\end{array}\right]<br>$$<br>q2右乘q1<br>$$<br>q_{2} q_{1}=\left[\begin{array}{cccc}<br>a &amp; -b &amp; -c &amp; -d \\<br>b &amp; a &amp; d &amp; -c \\<br>c &amp; -d &amp; a &amp; b \\<br>d &amp; c &amp; -b &amp; a<br>\end{array}\right]\left[\begin{array}{l}<br>e \\<br>f \\<br>g \\<br>h<br>\end{array}\right]<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法基础</title>
      <link href="2020/11/20/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/20/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p>摘自<a href="https://www.jianshu.com/p/191d1e21f7ed/" target="_blank" rel="noopener">https://www.jianshu.com/p/191d1e21f7ed/</a></p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推</p><p>注：标准语法一般在#后跟个<strong>空格</strong>再写文字</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h4><p>要加粗的文字左右分别用<strong>两个*</strong>号包起来</p><h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><p>要倾斜的文字左右分别用<strong>一个*</strong>号包起来</p><h4 id="倾斜加粗"><a href="#倾斜加粗" class="headerlink" title="倾斜加粗"></a>倾斜加粗</h4><p>要倾斜和加粗的文字左右分别用<strong>三个*</strong>号包起来</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>三个或者三个以上的 - 或者 * 都可以</p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><pre><code>[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加[简书](http://jianshu.com)[百度](http://baidu.com)</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>图床的创建：<br><a href="https://murmuroftheheart7.github.io/page/2/" target="_blank" rel="noopener">鲁大师教你做图床</a></p><p>将本地图片推到码云仓库：</p><pre><code>#/home/xx/gitee/dmzecho.gitee.io      本地图片存放位置$ git add .#添加文件到版本控制 .代表全部$ git commit -m &quot;aaa&quot;#提交到本地库，-m 添加备注$ git push origin master#把本地仓库的文件推送到远程仓库#同时，每次上传完成后，都要手动的打开Gitee Pages更新部署一下，否则新图片将无法访问</code></pre><p>Markdown中图片的使用：</p><pre><code>![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</code></pre><p>示例：</p><pre><code>![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;)</code></pre><p>效果展示：</p><p><img src="https://gitee.com/dmzecho/dmzecho.gitee.io/raw/master/Chongqing.jpg" alt="my_best_photo" title="重庆"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu学习</title>
      <link href="2020/11/19/Ubuntu%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/11/19/Ubuntu%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="Ubuntu学习"><a href="#Ubuntu学习" class="headerlink" title="Ubuntu学习"></a>Ubuntu学习</h3><pre><code>touch    #新建一个空文件</code></pre><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p>文件——文件</p><p>目录——文件夹</p><h3 id="git更新至最新版本"><a href="#git更新至最新版本" class="headerlink" title="git更新至最新版本"></a>git更新至最新版本</h3><p>1、查看git版本</p><pre><code>git --version</code></pre><p>2、添加Git官方的软件源</p><pre><code>sudo add-apt-repository ppa:git-core/ppa</code></pre><p>3、更新列表</p><pre><code>sudo apt updatesudo apt install -fsudo apt upgrade</code></pre><h3 id="表示根目录"><a href="#表示根目录" class="headerlink" title="/表示根目录"></a>/表示根目录</h3><p>Linux中没有盘符的概念，所有文件都是由根目录开始，重要的有 /home     </p><p>/etc  系统配置文件存放目录</p><p>/bin 可使用的二进制文件的目录，如常用的ls、tar、cat等</p><h3 id="～表示家目录（-home-xx）"><a href="#～表示家目录（-home-xx）" class="headerlink" title="～表示家目录（/home/xx）"></a>～表示家目录（/home/xx）</h3><h3 id="linux常用指令"><a href="#linux常用指令" class="headerlink" title="linux常用指令"></a>linux常用指令</h3><pre><code>command  [-options]  [parameter]#[]表示可省略，parameter意为参数pwd      #查看当前所在的路径touch    #新建文件mkdir    #新建文件夹rm + 文件名      #删除文件clear    #清屏ctrl + shift + =    #放大终端字体Ctrl + -    #缩小终端字体</code></pre><h3 id="查阅命令帮助信息-速查"><a href="#查阅命令帮助信息-速查" class="headerlink" title="查阅命令帮助信息(速查)"></a>查阅命令帮助信息(速查)</h3><pre><code>command --help  man commandenter键——多显示一行空格键——多显示一页b——回滚一页，backwardf——前滚一页，forwardq——退出</code></pre><h3 id="隐藏文件"><a href="#隐藏文件" class="headerlink" title="隐藏文件"></a>隐藏文件</h3><p>命名以.开头的文件都是隐藏文件</p><h3 id="和"><a href="#和" class="headerlink" title=".和.."></a>.和..</h3><p>.表示当前目录，cd .命令不会切换目录</p><p>..表示上一层，cd ..  回到上一层</p><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><pre><code>ls -a  #显示目录下所有内容（包括隐藏文件）ls -l  #以列表显示，并显示详细信息ls -l -h #文件大小显示更人性化# drwxrwxr-x 26 xx   xx   4.0K 8月  26 16:54 anaconda3ls -a -l -h #显示最全面</code></pre><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p><em>可代表*</em>任意个数**的字符（也可以没有）</p><p>？可代表<strong>任意一个</strong>字符</p><h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><pre><code>cd       /home/xxcd ~    /home/xxcd .    当前cd ..    上一目录cd -    切换到上次所在目录</code></pre><h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><pre><code>mkdir -p #递归创建目录   mkdir -p a/b/c/d#同一目录下，文件和目录也不能重名</code></pre><h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><p>rm命令删除的文件不能恢复</p><pre><code>rm -r #删除目录rm -f #忽略不存在的文件，强制删除</code></pre><h3 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a>tree命令</h3><p>以树状图显示目录结构</p><pre><code>tree -d #只显示目录，不显示文件</code></pre><h3 id="cp（复制）和mv（移动）"><a href="#cp（复制）和mv（移动）" class="headerlink" title="cp（复制）和mv（移动）"></a>cp（复制）和mv（移动）</h3><h4 id="cp——copy"><a href="#cp——copy" class="headerlink" title="cp——copy"></a>cp——copy</h4><pre><code>cp 文件完整路径+文件名  文件目标位置(+新的名字)    缺省表示名字不变cp ~/anaconda3/LICENSE.txt ~/桌面/a.txtcp -i #有重名会提示cp -r #复制目录包括其中的所有内容</code></pre><h4 id="mv——move"><a href="#mv——move" class="headerlink" title="mv——move"></a>mv——move</h4><pre><code>mv 文件（目录）的路径  目标路径mv -i #警示mv 旧文件名 新文件名     #同一目录下文件重命名，目录重命名也是同理</code></pre><h3 id="grep文本搜索"><a href="#grep文本搜索" class="headerlink" title="grep文本搜索"></a>grep文本搜索</h3><pre><code>grep [-n] an a.txt    #在a.txt中搜索an    -n显示出对应的行号grep -i #忽略大小写grep -ni &quot;hello python&quot;  #中间有空格</code></pre><h3 id="echo和重定向"><a href="#echo和重定向" class="headerlink" title="echo和重定向"></a>echo和重定向</h3><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>将后面的内容打印在终端中</p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><pre><code>&gt;   #将应该显示到终端中的内容输出到指定文件中echo hello &gt; a.txt      #将hello输出到a.txt，会覆盖原有内容，没有则会新建文件echo hello &gt;&gt; a.txt     #将hello追加到文件的末尾ls -lh &gt; a.txt   </code></pre><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>将一个命令的输出作为下一个命令的输入，常用more（分屏显示）grep（查找）</p><pre><code>ls -lha ~ | more    #家目录下的所有文件（目录）信息分屏显示ls -lha /home/xx/myblog | grep -i pu</code></pre><h3 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h3><pre><code>shutdown    #一分钟后关机shutdown nowshutdown 23:00shutdown +10 #十分钟后关机shutdown -c  #取消关机</code></pre><h3 id="ifconfig和ping"><a href="#ifconfig和ping" class="headerlink" title="ifconfig和ping"></a>ifconfig和ping</h3><pre><code>127.0.0.1  #本地环回ping 127.0.0.1</code></pre><h3 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h3><pre><code>-  rw-  rw-  r-- 1 xx xx 4.5K 11月 11 20:56 a.txt#权限每3个一组，读、写、执行    xx文件（目录）的拥有者的权限    xx文件（目录）组对应的权限   其他人的权限</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python学习</title>
      <link href="2020/11/19/Python%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/11/19/Python%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Python学习"><a href="#Python学习" class="headerlink" title="Python学习"></a>Python学习</h1><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><pre><code>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 </code></pre><h4 id="列表赋值"><a href="#列表赋值" class="headerlink" title="列表赋值"></a>列表赋值</h4><p>​        如果采用直接列表相等的赋值方式，则当原列表原始变化的时候，被赋值的变量的列表内容也会发生变化。</p><pre><code>my_fruits=[&quot;apple&quot;,&quot;banana&quot;,&quot;juice&quot;]your_fruits=my_fruitsprint(your_fruits)my_fruits.append(&quot;mango&quot;)print(your_fruits)</code></pre><p>​        输出结果为</p><pre><code>[&quot;apple&quot;,&quot;banana&quot;,&quot;juice&quot;][&quot;apple&quot;,&quot;banana&quot;,&quot;juice&quot;,&quot;mango&quot;]</code></pre><p>​        比较另外一种赋值方式</p><pre><code>my_fruits=[&quot;apple&quot;,&quot;banana&quot;,&quot;juice&quot;]we_fruits=my_fruits[:]my_fruits.append(&quot;mango&quot;)print(we_fruits)</code></pre><p>​        输出结果为</p><pre><code>[&quot;apple&quot;,&quot;banana&quot;,&quot;juice&quot;]</code></pre><p>​        这种赋值方式相当于创建了一个列表，使得列表的元素和之前列表的元素相同，但并不等同于之前的列表，因此列表内容不会随着原列表内容发生变化而变化</p><pre><code>data=[[1,2,3],[4,5,6],[7,8,9]]data[1],[2]=100 #给第二个第三列的数进行赋值print(data)</code></pre><p>​        输出结果为</p><pre><code>[[1,2,3],[4,5,100],[7,8,9]]</code></pre><h4 id="元组和列表"><a href="#元组和列表" class="headerlink" title="元组和列表"></a>元组和列表</h4><p>​        表示方法：元组用（）表示，列表用[ ]表示</p><p>​        含义区别：元组的元素<strong>不能</strong>修改，列表可以重新赋值</p><p>​        <em>注意：元组中只包含一个元素时，需要在元素后面添加逗号</em>，如：</p><pre><code>tup1 = (50,)</code></pre><h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>​        输出2至100内的所有质数</p><p>用for循环写：</p><pre><code>i=2for num in range(2,101):    for i in range(2,num//2):        if not(num%i):        break    if i&gt;num/i:      #把2也能括进去        print(num,&quot;是质数&quot;)print(&quot;over&quot;)</code></pre><p>并用一个列表输出</p><pre><code>i=2n=[]j=0for num in range(2,101):    for i in range(2,num//2):        if not(num%i):            break    if i&gt;num/i:                  n.insert(j, num)        j+=1print(n)</code></pre><p>用while循环写：</p><pre><code>num=2while(num&lt;=100):    i=2    while(i&lt;=num/i):        if(not(num%i)):        break    i=i+1    if(i&gt;num/i):        print(num,&apos;是质数&apos;)    num=num+1print(&apos;over&apos;)</code></pre><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><p>浅拷贝：</p><pre><code>a = {1: [1,2,3]}b = a.copy()   #a和b是同一片内存地址</code></pre><p>深拷贝：</p><pre><code>import copyc = copy.deepcopy(a)   #a和c是两片内存地址</code></pre><h4 id="空间两点间欧氏距离计算"><a href="#空间两点间欧氏距离计算" class="headerlink" title="空间两点间欧氏距离计算"></a>空间两点间欧氏距离计算</h4><pre><code>left = [0.3960, -0.2886, 0.9663]obj = [0.4, 0.3, 0.96]left_end = numpy.asarray([left[0],left[1],left[2]])obj_end = numpy.asarray([obj[0],obj[1],obj[2]])left_obj = left_end - obj_enda = numpy.sqrt(numpy.inner(left_obj, left_obj))</code></pre><h4 id="向txt文件中写入变量值"><a href="#向txt文件中写入变量值" class="headerlink" title="向txt文件中写入变量值"></a>向txt文件中写入变量值</h4><pre><code># r，只读模式【默认模式，文件必须存在，不存在则抛出异常】# w，只写模式【不可读；不存在则创建；存在则清空内容】# a， 只追加写模式【不可读；不存在则创建；存在则只追加内容】file_handle=open(&apos;c.txt&apos;,mode=&apos;a&apos;)      file_handle.write(str(fx_z))       #fx_z为变量名file_handle.write(&apos;\n&apos;)file_handle.close()</code></pre><h4 id="从txt文件中读取数据"><a href="#从txt文件中读取数据" class="headerlink" title="从txt文件中读取数据"></a>从txt文件中读取数据</h4><pre><code>vec = np.genfromtxt(&apos;wiki.ch.text.vector&apos;, skip_header=1, delimiter=&apos; &apos;, dtype=None)# vec为变量名,类型为ndarray# &apos;wiki.ch.text.vector&apos; 为 路径 +文件名# skip_header=1 ,跳过第一行# delimiter=&apos; &apos;,分隔符# 因为txt中有str和float，所以要设置dtype=None，默认只会读float所以会报错</code></pre><h4 id="python画图"><a href="#python画图" class="headerlink" title="python画图"></a>python画图</h4><pre><code>#   画三维图 import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3D%matplotlib widget         # conda install -c conda-forge ipympl  安装三维图旋转插件ax = plt.axes(projection=&apos;3d&apos;)ax.plot3D(rDataj[0,:],rDataj[1,:],rDataj[2,:])#   画二维图import matplotlib.pyplot as plt%matplotlib widgetplt.plot(rDataj[0,:])plt.plot(rDataj[1,:])plt.plot(rDataj[2,:])</code></pre><h4 id="numpy模块常用的矩阵函数"><a href="#numpy模块常用的矩阵函数" class="headerlink" title="numpy模块常用的矩阵函数"></a>numpy模块常用的矩阵函数</h4><pre><code>import numpy as npnp.array()    #创建 ndarray 数组[[ ]，[ ],、、、]np.zeros((3,2))   # 创建3×2的ndarray  np.zeros((3,))维度为1np.empty()          #与np.zeros()类似    np.dot( , )            #矩阵乘法np.linalg.det()   #方阵行列式np.linalg.inv()   #矩阵求逆np.sum()b=np.array([[ 0,  1,  2,  3,  4,  5],   [ 6,  7,  8,  9, 10, 11]])&gt;&gt;&gt; np.sum(b)    #默认对所有元素进行求和66&gt;&gt;&gt; np.sum(b,axis=0)        #在第一个轴展开方向上求和array([ 6,  8, 10, 12, 14, 16])&gt;&gt;&gt; np.sum(b,axis=1)array([15, 51])</code></pre><h4 id="常用的矩阵维度变换函数"><a href="#常用的矩阵维度变换函数" class="headerlink" title="常用的矩阵维度变换函数"></a>常用的矩阵维度变换函数</h4><pre><code>.reshape()      #a.reshape(3,2)  将a变成3行2列a=np.array([[1,2,3],[3,2,1]])b=a.reshape(-1,1)    #变成列向量，访问b中元素，用b[i]，或者b[i,j]。b[i]表示输出b的第i行b=a.reshape(1,-1)    #变成行向量，访问b中元素，用b[i,j]a=np.array([[1,2,3],[3,2,1]])b=a.reshape(1,-1)     #b.shape = (1,6),[[1,2,3,3,2,1]],b[0]=[1 2 3 3 2 1]c=a.flatten()          #c.shape = (6,),[1,2,3,3,2,1],c[0]=1.flatten()      #变成一维.shape          #查看矩阵或者数组的维度a.shape[0]    #只返回矩阵的行数a.shape[1]    #只返回矩阵的列数</code></pre><h4 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h4><pre><code>a=&quot;啦啦啦&quot;b=&quot;哦哦哦哦哦哦哦哦哦&quot;c=a+bprint c     #啦啦啦哦哦哦哦哦哦哦哦哦</code></pre><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><pre><code>#  %s——字符串，%d——整数，%f——浮点数d=5.00e=2f=10.00print(&quot;苹果单价为%.2f元/斤，购买了%d斤，需要支付%.2f元&quot; % (d,e,f))     # %.2f保留两位小数的浮点数#(d,e,f)是一个元组tup=(d,e,f)print(&quot;苹果单价为%.2f元/斤，购买了%d斤，需要支付%.2f元&quot; % tup)输出结果一致</code></pre><h4 id="elif"><a href="#elif" class="headerlink" title="elif"></a>elif</h4><pre><code>score=79if score&lt;60:    print(&quot;不及格&quot;)elif score&lt;70:    print(&quot;及格&quot;)elif score&lt;90:    print(&quot;良好&quot;)else:    print(&quot;优秀&quot;)# elif = else if</code></pre><h4 id="末尾取消换行和追加换行"><a href="#末尾取消换行和追加换行" class="headerlink" title="末尾取消换行和追加换行"></a>末尾取消换行和追加换行</h4><pre><code>#此方法局限于python3for i in range (1,10):    for j in range(1,i+1):        print(&quot;%d * %d = %d  &quot; %(i,j,i*j) , end=&quot;&quot;)     # end=为跟在后面输出的，代替了默认的换行符    print(&quot;\n&quot;)         # 或print(&quot;&quot;),追加换行符#python2i=1while(i&lt;=5):    j=1    while(j&lt;=i):        print(&quot;*&quot;),      #在输出末尾追加“，”来取消换行        j=j+1    print(&quot;&quot;)    i=i+1</code></pre><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>每一个以.py结尾的Python源代码都是一个模块，用<em>import</em>导入,命名不能以数字开头<br>模块中定义的<strong>全局变量</strong>、<strong>函数</strong>都可以在外部直接使用</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表用[]定义,数据之间用“，”分隔，索引（下标）从0开始<br>列表中的数据类型可以不一致</p><h5 id="列表的增、删、改、查、长度"><a href="#列表的增、删、改、查、长度" class="headerlink" title="列表的增、删、改、查、长度"></a>列表的增、删、改、查、长度</h5><pre><code>#查找name_list = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;]print(name_list[0])print(name_list.index(&quot;wangwu&quot;))#修改name_list = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;]name_list[1]=&quot;李四&quot;        #中文字符在python2中会出现乱码print(name_list)#添加name_list.append(&quot;zhaoliu&quot;)    #在末尾追加，且只能追加一个name_list = [1,2,3,4]name_list.insert(2,5)       #.insert(index,数据)print(name_list)         #[1,2,5,3,4]temp_list=[6,7,8,9]name_list.extend(temp_list)     #列表的拼接#删除name_list=[1,2,3,4,5,6]name_list.remove(4)     #[1,2,3,5,6] ,remove能删除指定元素（第一次出现）name_list.pop()    #[1,2,3,5] ,pop默认删除最后一个元素（最后进列表，最先被删除），.pop(index)能删除指定索引的元素name_list.clear()   #清空列表name_list = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;]     del name_list[0]      #del关键字能删除列表元素print(name_list)     #[&apos;lisi&apos;,&apos;wangwu&apos;]a=10del a                #删除变量 print(a)          #报错#列表长度name_list = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;]     print(name_list)a=len(name_list)print(a)                #3#元素出现次数b=name_list.count(&quot;zhangsan&quot;)print(b)    </code></pre><h4 id="python中的引号"><a href="#python中的引号" class="headerlink" title="python中的引号"></a>python中的引号</h4><p>python中“ ”与‘ ’在表示字符串时是没有区别的<br>在输出时，输出内容有“ ”（双引号）则在单引号内使用双引号，即‘“要输出内容”’；<br>输出内容有‘ ’（单引号）则在双引号内使用单引号，即“‘要输出内容‘“；<br>补充：’’’ (三引号)用法：<br>1、用作多行注释；2、用作表示一个字符串<br>注：python中并没有提供专门的多行注释的符号，当一串字符被三引号引用时，但它不作为字符串被操作时，这个三引号内引用的内容就被视为注释。</p><h4 id="函数与方法"><a href="#函数与方法" class="headerlink" title="函数与方法"></a>函数与方法</h4><p>函数名(参数)      #函数的调用，len(name_list)<br>对象.方法名(参数)     #方法的调用，b=name_list.count(“zhangsan”)</p><h4 id="列表倒序排列"><a href="#列表倒序排列" class="headerlink" title="列表倒序排列"></a>列表倒序排列</h4><pre><code>aa=[2,5,1,8,3,7]first=0last=len(aa)-1while(first&lt;last):    bb=aa[first]    aa[first]=aa[last]    aa[last]=bb    first+=1    last-=1print(aa)#相当于aa.reverse()</code></pre><h5 id="列表的升序和降序"><a href="#列表的升序和降序" class="headerlink" title="列表的升序和降序"></a>列表的升序和降序</h5><pre><code>aa=[2,5,1,8,3,7] aa.sort()        #升序aa.sort(reverse=True)    #降序</code></pre><h4 id="列表遍历"><a href="#列表遍历" class="headerlink" title="列表遍历"></a>列表遍历</h4><pre><code>name_list=[&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;]for i in name_list:    print(i,end=&quot; &quot;)</code></pre><h4 id="列表的"><a href="#列表的" class="headerlink" title="列表的+="></a>列表的+=</h4><pre><code>#列表的“+=”相当于.extend(),所以外部实参的值也会改变。而不是对应元素相加再赋值num_list1=[1,2,3]num_list2=[4,5,6]num_list1+=num_list2print(num_list1)</code></pre><h4 id="元组与列表"><a href="#元组与列表" class="headerlink" title="元组与列表"></a>元组与列表</h4><p>元组的元素不能修改<br>元组用“()”定义<br>元组的使用场景<br>1、做函数的参数和返回值（可以存放多个类型不同的数据）<br>特别是要返回多个数据的值，常以元组的形式 return(变量1，变量2，变量3，…)</p><pre><code>def pr1():    # print(&quot;num的值为%d,地址为%d&quot; % (num,id(num)))    heig=1.75    weig=120    return (heig,weig)gl_h,gl_w=pr1()     #用多个变量去接受元组的元素，方便之后使用print(&quot;身高为：%.2f&quot;%gl_h)print(&quot;体重为：%.2f&quot;%gl_w)#身高为：1.75#体重为：120.00#用变量接收元组的元素a=6b=100b,a=(a,b)   #不使用第三个变量，交换两个变量的值print(a)print(b)</code></pre><p>2、列表-&gt;元组，保护数据不被修改</p><h5 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h5><p>list(元组)<br>tuple(列表)</p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>用<strong>键值对</strong>（key-value）的形式保存无序的数据集合<br><strong>值</strong>可以是任何数据类型，但<strong>键</strong>只能是<em>字符串、数字和元组</em></p><h4 id="字典的合并"><a href="#字典的合并" class="headerlink" title="字典的合并"></a>字典的合并</h4><pre><code>#update方法，如果key相同会覆盖原有的键值对oran_dic = {&quot;name&quot;:&quot;orange&quot;}temp_dic={&quot;weight&quot;:1.8}oran_dic.update(temp_dic)print(oran_dic)</code></pre><h4 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h4><pre><code>#for循环得到的是字典的keyoran_dic = {&quot;name&quot;:&quot;orange&quot;,&quot;weight&quot;:1.8}for i in oran_dic:    print(&quot;%s-%s&quot;%(i,oran_dic[i]))#输出name-orange,weight-1.8</code></pre><h4 id="字典做列表元素"><a href="#字典做列表元素" class="headerlink" title="字典做列表元素"></a>字典做列表元素</h4><pre><code>phon_lis = [    {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18,&quot;phone&quot;:&quot;12345&quot;},    {&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:16,&quot;phone&quot;:&quot;23456&quot;}    ]print(phon_lis)for i in phon_lis:       #列表的循环遍历，i是列表中的每个元素（字典）    for j in i:          #字典的循环遍历，j是每个key        print(&quot;%s-%s&quot; % (j,i[j]), end=&quot; &quot;)    print(&quot;&quot;)#[{&apos;name&apos;: &apos;zhangsan&apos;, &apos;age&apos;: 18, &apos;phone&apos;: &apos;12345&apos;}, {&apos;name&apos;: &apos;lisi&apos;, &apos;age&apos;: 16, &apos;phone&apos;: &apos;23456&apos;}]name-zhangsan age-18 phone-12345 name-lisi age-16 phone-23456 </code></pre><h4 id="字符串的分割-split"><a href="#字符串的分割-split" class="headerlink" title="字符串的分割(.split)"></a>字符串的分割(.split)</h4><pre><code>str = &quot;Line1-abcdef \nLine2-abc \nLine4-abcd&quot;str.split(&quot; &quot;,2)       #指定以“ ”作为分隔符，切分2次，分成3块#不指定分隔符，则默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等#split方法返回数据类型为列表</code></pre><h4 id="元素拼成字符串-join"><a href="#元素拼成字符串-join" class="headerlink" title="元素拼成字符串(.join)"></a>元素拼成字符串(.join)</h4><pre><code>tup=(&quot;1,2,3&quot;,&quot;zhangsan&quot;)str_2=&quot; &quot;.join(tup)      #元组元素的拼接，每个元素必须是字符串，指定以“ ”作为分隔符print(str_2)#1,2,3 zhangsanlis=[&quot;1,2,3&quot;,&quot;zhangsan&quot;]str_3=&quot;\t&quot;.join(lis)      #列表字符串元素的拼接print(str_3)#1,2,3   zhangsandic={&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18}str_4=&quot;\n&quot;.join(dic)       #字典key的拼接print(str_4)#name#age</code></pre><h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><pre><code>#取出指定索引中间的字符串,结束索引对应的元素取不到#对于列表、元组（有序的对象）都可以用切片#如字符串”python&quot;，0p1y2t3h4o5n，p-6y-5t-4h-3o-2n-1#str[0:5:1],在索引0和5切割，步长为1，取出&quot;pytho&quot;str_5=&quot;元素拼成的字符串payatahaoan&quot;temp_str=str_5[8::2]     #结束索引不指定，能取到最后一个元素print(temp_str)#python</code></pre><h4 id="字符串逆序"><a href="#字符串逆序" class="headerlink" title="字符串逆序"></a>字符串逆序</h4><pre><code>str_6=&quot;python&quot;print(str_6[::-1])  #等价于str_6[-1::-1]</code></pre><h4 id="max和min函数"><a href="#max和min函数" class="headerlink" title="max和min函数"></a>max和min函数</h4><pre><code>#对于列表、元组、字典（key）、字符串都适用list_b=[&quot;0&quot;,&quot;Ab&quot;,&quot;cccc&quot;]print(max(list_b))#cccc#字符比较大小遵循&quot;0&quot;&lt;&quot;A&quot;&lt;&quot;a&quot;(ASCII码顺序)</code></pre><h4 id="for…else…"><a href="#for…else…" class="headerlink" title="for…else…"></a>for…else…</h4><pre><code>list_c=&quot;abcdefghi&quot;find_str=&quot;e&quot;for i in range(len(list_c)):      #用i做索引变量，便于输出    if(list_c[i]==find_str):        print(i)        breakelse:                            #整个循环完全走完，没有中途退出，会执行else语句    print(&quot;列表中没有字母%s&quot;% find_str)  name_list=[{&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:&quot;18&quot;,&quot;phone&quot;:&quot;123456&quot;},{&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:&quot;17&quot;,&quot;phone&quot;:&quot;234567&quot;},{&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:&quot;19&quot;,&quot;phone&quot;:&quot;345678&quot;},{&quot;name&quot;:&quot;zhaoliu&quot;,&quot;age&quot;:&quot;16&quot;,&quot;phone&quot;:&quot;456789&quot;}]#遍历整个列表for i in name_list:    if(i[&quot;name&quot;]==&quot;wangwu&quot;):        #遍历整个字典        for j in i:            print(&quot;%s-%s&quot;% (j,i[j]),end=&quot; &quot;)   #格式化输出字典         print(&quot;&quot;)        breakelse:    print(&quot;查无此人！&quot;)</code></pre><h4 id="实例-名片管理系统"><a href="#实例-名片管理系统" class="headerlink" title="实例-名片管理系统"></a>实例-名片管理系统</h4><pre><code>#! /home/xx/anaconda3/bin/pythondef new_name(name_list):    &quot;&quot;&quot;添加联系人&quot;&quot;&quot;    n=input(&quot;请输入添加的联系人姓名：&quot;)    a=input(&quot;请输入添加的联系人年龄：&quot;)    p=input(&quot;请输入添加的联系人电话：&quot;)    temp_tup={&quot;name&quot;:n,&quot;age&quot;:a,&quot;phone&quot;:p}    name_list.append(temp_tup)    return name_listdef show_name(name_list):    &quot;&quot;&quot;显示全部联系人&quot;&quot;&quot;    for i in name_list:        for j in i:            print(&quot;%s-%s&quot; % (j,i[j]),end=&quot; &quot;)        print(&quot;&quot;)def find_name(name_list):    &quot;&quot;&quot;查找、修改、删除联系人&quot;&quot;&quot;    n=input(&quot;请输入需要查找的联系人：\n&quot;)    for i in name_list:        if(i[&quot;name&quot;]==n):            for j in i:                print(&quot;%s-%s&quot; % (j,i[j]),end=&quot; &quot;)            print(&quot;&quot;)            while(1):                aa=input(&quot;需要修改请输入1，需要删除请输入2，退出查询请输入3\n&quot;)                if(aa==&quot;1&quot;):                    n_1=input(&quot;请输入姓名：&quot;)                    a_1=input(&quot;请输入年龄：&quot;)                    p_1=input(&quot;请输入电话：&quot;)                    i[&quot;name&quot;]=n_1                    i[&quot;age&quot;]=a_1                    i[&quot;phone&quot;]=p_1                    return name_list                elif(aa==&quot;3&quot;):                    return name_list                elif(aa==&quot;2&quot;):                    name_list.remove(i)                    return name_list                else:                    print(&quot;输入有误，请重新输入&quot;)    else:        print(&quot;查无此人&quot;)        return name_listprint(&quot;*************&quot;)print(&quot;欢迎使用名片管理系统&quot;)print(&quot;1、新建名片&quot;)print(&quot;2、显示全部&quot;)print(&quot;3、查询名片&quot;)print(&quot;0、退出系统&quot;)print(&quot;************&quot;)name_list=[    {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18,&quot;phone&quot;:&quot;123456&quot;},    {&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:19,&quot;phone&quot;:&quot;234567&quot;},    {&quot;name&quot;:&quot;王五&quot;,&quot;age&quot;:20,&quot;phone&quot;:&quot;345678&quot;}]while(1):    a=input(&quot;请输入操作对应编号\n&quot;)    if(a==&quot;1&quot;):        name_list=new_name(name_list)    elif(a==&quot;0&quot;):        print(&quot;使用完毕&quot;)        break    elif(a==&quot;2&quot;):        show_name(name_list)    elif(a==&quot;3&quot;):        name_list=find_name(name_list)</code></pre><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><pre><code>a=1</code></pre><p>变量a存储的是数据1的地址（引用）</p><p>先看=右侧，开辟一块内存地址，其中存放数据1，让变量a指向这块内存地址</p><p>函数中的参数传递，实参-&gt;形参（或返回值的传递），传递的不是数据本身，而是引用，即传递的是数据的内存地址</p><p>当调用函数时，数据从实参-&gt;形参，相当于这两个变量都是指向这个数据的引用<br>在函数内部的<strong>赋值操作</strong>不会影响实参的大小<br>但是如果参数是<strong>可变数据类型</strong>，在函数内部用<strong>方法</strong>修改了数据，会影响外部的数据</p><h4 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h4><p>局部变量的生命周期：<br>局部变量在<strong>函数执行</strong>时才会被创建<br>函数执行结束后局部变量被系统回收<br>局部变量在生命周期內,可以用来存储函数内部临时使用到的数据</p><p>全局变量（不在某个函数内部定义的变量）均为全局变量<br>全局变量的值在函数内部不能直接修改<br>修改需要使用<strong>global</strong>关键字<br>全局变量命名：建议以<strong>g_</strong>（或<strong>gl_</strong>）开头</p><pre><code>def pr1():    global g_num    #指明是全局变量num    g_num=10        #修改全局变量的值    print(&quot;g_num的值为%d,地址为%d&quot; % (g_num,id(g_num)))    #id()函数:返回数据（或变量所存数据）的地址def pr2():    print(&quot;g_num的值为%d,地址为%d&quot; % (g_num,id(g_num)))def pr3():    print(&quot;g_num的值为%d,地址为%d&quot; % (g_num,id(g_num))g_num =100pr1()pr2()pr3()#g_num的值为10,地址为94013836051488#g_num的值为10,地址为94013836051488#g_num的值为10,地址为94013836051488</code></pre><h4 id="多值参数"><a href="#多值参数" class="headerlink" title="多值参数"></a>多值参数</h4><pre><code>#元组作为参数(常规)def sum_numbers(n_tup):    num_sum=0    for i in n_tup:        num_sum+=i    return num_sumgl_sum=sum_numbers((1,2,3,4,5))    #不方便阅读print(gl_sum) #元组作为参数(多值参数)def sum_numbers(*n_tup):    num_sum=0    for i in n_tup:    #n_tup当成正常元组使用即可        num_sum+=i    return num_sumgl_sum=sum_numbers(1,2,3,4,5)print(gl_sum)</code></pre><h4 id="作图"><a href="#作图" class="headerlink" title="作图"></a>作图</h4><pre><code>import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3D   #引入画图工具包from matplotlib.font_manager import FontProperties  #设置字体#导入所需要的字体，如宋体songti = FontProperties(fname=r&quot;/home/xx/fonts/simsun.ttf&quot;, size=10)  plt.rcParams[&quot;font.family&quot;] = &quot;Times New Roman&quot;     #未指定，默认是Times New Romanplt.rcParams[&quot;font.size&quot;] = &quot;10&quot;plt.rcParams[&quot;text.usetex&quot;] = Falseplt.rcParams[&apos;axes.unicode_minus&apos;] =False#设置图幅的长和宽，这里是论文单栏双图fig_width = 190/25.4  # mm to inchfig, ax = plt.subplots(ncols=2, figsize=(fig_width, fig_width/2 *4/5))#具体的画图代码t = np.linspace(0,10,100)   #t.shape = (100,)a=np.sin(t)b=np.cos(t)# ax[0].axis(&apos;equal&apos;);ax[1].axis(&apos;equal&apos;)    #横纵坐标尺度一致ax[0].plot(t,a,color=&apos;r&apos;,linewidth=2,label =u&apos;正弦曲线&apos;)   #打上标签，方便写图例ax[0].plot(t,b,color=&apos;b&apos;,linewidth=2,label =u&apos;余弦曲线&apos;) ax[0].set_xlim([min(t),max(t)])ax[0].set_ylim([min(a)-0.1,max(a)+0.5])legend_pos=(1.01,1.02)ax[0].legend(loc=&apos;upper right&apos;, bbox_to_anchor=legend_pos,ncol=2,handlelength=1,prop=songti)ax[0].set_xlabel(&apos;t [s]&apos;)ax[0].set_ylabel(u&apos;坐标值 [m]&apos;,FontProperties=songti)paper_path = &apos;figures&apos;fig.savefig(paper_path+&apos;xxxxxxxx.pdf&apos;,format=&apos;pdf&apos;,bbox_inches=&apos;tight&apos;,  pad_inches=0.0)</code></pre><h4 id="np-linalg-norm-范数"><a href="#np-linalg-norm-范数" class="headerlink" title="np.linalg.norm(范数)"></a>np.linalg.norm(范数)</h4><p>参考<a href="https://blog.csdn.net/hqh131360239/article/details/79061535" target="_blank" rel="noopener">np.linalg.norm(求范数)</a><br><img src="https://gitee.com/dmzecho/dmzecho.gitee.io/raw/master/%E8%8C%83%E6%95%B0.png" alt="范数" title="范数"></p><pre><code>#常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小#np.linalg.norm()，默认是二范数，即元素的平方和开根号import numpy as npx = np.array([    [0, 3, 4],    [1, 2, 3],    [4, 5, 6]])#默认参数ord=None，axis=None，keepdims=Falseprint &quot;默认参数(矩阵整体元素平方和开根号，不保留矩阵二维特性)：&quot;,np.linalg.norm(x)print &quot;矩阵整体元素平方和开根号，保留矩阵二维特性：&quot;,np.linalg.norm(x,keepdims=True)a = np.linalg.norm(x,keepdims=True)print(a.shape)print &quot;矩阵每个行向量求向量的2范数：&quot;,np.linalg.norm(x,axis=1,keepdims=True)print &quot;矩阵每个列向量求向量的2范数：&quot;,np.linalg.norm(x,axis=0,keepdims=True)print &quot;矩阵1范数：&quot;,np.linalg.norm(x,ord=1,keepdims=True)print &quot;矩阵2范数：&quot;,np.linalg.norm(x,ord=2,keepdims=True)print &quot;矩阵∞范数：&quot;,np.linalg.norm(x,ord=np.inf,keepdims=True)print &quot;矩阵每个行向量求向量的1范数：&quot;,np.linalg.norm(x,ord=1,axis=1,keepdims=True)</code></pre><p>输出内容：</p><pre><code>默认参数(矩阵整体元素平方和开根号，不保留矩阵二维特性)： 10.770329614269007矩阵整体元素平方和开根号，保留矩阵二维特性： [[10.77032961]](1, 1)矩阵每个行向量求向量的2范数： [[5.        ][3.74165739][8.77496439]]矩阵每个列向量求向量的2范数： [[4.12310563 6.164414   7.81024968]]矩阵1范数： [[13.]]矩阵2范数： [[10.56733812]]矩阵∞范数： [[15.]]矩阵每个行向量求向量的1范数： [[ 7.][ 6.][15.]]</code></pre><h4 id="读-mat文件"><a href="#读-mat文件" class="headerlink" title="读.mat文件"></a>读.mat文件</h4><pre><code>import scipy.io as sciodataFile = &apos;/home/xx/project/ur5e_basic/src/franka_basic/DS-master/bottle.mat&apos;data = scio.loadmat(dataFile)print type(data)     #类型为字典vicon_bottle = np.zeros((483,7))for i in range(483):    vicon_bottle[i,:] = data[&apos;a&apos;][i,:]     #key为a</code></pre><h4 id="np-concatenate-矩阵拼接"><a href="#np-concatenate-矩阵拼接" class="headerlink" title="np.concatenate 矩阵拼接"></a>np.concatenate 矩阵拼接</h4><pre><code>x = np.ones((100,1))y = np.zeros((100,1))# 若 x[100,1],y[100,1]xy = np.concatenate([x,y],axis = 0)# 按行拼接 ，xy[200,1]xy1 = np.concatenate([x,y],axis = 1)# 按列拼接 ，xy[100,2]</code></pre><h4 id="scipy-optimize-minimize-非线性规划（求区间上的最小值）"><a href="#scipy-optimize-minimize-非线性规划（求区间上的最小值）" class="headerlink" title="scipy.optimize.minimize 非线性规划（求区间上的最小值）"></a>scipy.optimize.minimize 非线性规划（求区间上的最小值）</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo配置</title>
      <link href="2020/11/19/Hexo%E9%85%8D%E7%BD%AE/"/>
      <url>2020/11/19/Hexo%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h1><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code>hexo new &quot;文件名&quot;    #新建.md文件hexo g       #生成静态文件hexo server  #启动服务器。默认情况下，访问网址为： http://localhost:4000/hexo d       #部署网站</code></pre><h4 id="常见错误及解决方法"><a href="#常见错误及解决方法" class="headerlink" title="常见错误及解决方法"></a>常见错误及解决方法</h4><pre><code>error: Spawn failedat ChildProcess.&lt;anonymous&gt; (/home/xx/myblog/node_modules/...)</code></pre><p>1.删除.deploy_git文件后重新部署</p><p>2.依次执行</p><pre><code>hexo clean hexo ghexo d</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++学习</title>
      <link href="2020/11/17/c++%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/11/17/c++%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="c-学习——By-Xie"><a href="#c-学习——By-Xie" class="headerlink" title="c++学习——By Xie"></a>c++学习——By Xie</h1><p>以下均为学习b站黑马程序员C++所做笔记，以及简单的学习心得<br><a href="https://www.bilibili.com/video/BV1et411b73Z" target="_blank" rel="noopener">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难</a></p><h4 id="VS使用技巧"><a href="#VS使用技巧" class="headerlink" title="VS使用技巧"></a>VS使用技巧</h4><p>注释：     先<strong>CTRL+K</strong>，然后<strong>CTRL+C</strong>          或者加//</p><p>取消注释： 先<strong>CTRL+K</strong>，然后<strong>CTRL+U</strong>    或者删除//</p><p>调试：<strong>F5</strong></p><p>单步执行：<strong>F10</strong></p><p>设置或者删除断点：<strong>F9</strong></p><p>查找：<strong>CTRL+Shift+F</strong></p><p>跳转到变量/函数的定义：<strong>F12</strong></p><pre><code>system(&quot;pause&quot;)   //显示按任意键继续system(&quot;cls&quot;)     //清屏</code></pre><p>程序执行到return,会直接跳出该函数</p><h4 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h4><p>sizeof（数据类型/变量名）</p><pre><code>int arr[10]={、、、};int a= sizeof(arr)/sizeof(arr[0]);     //常用来求数组元素个数</code></pre><h4 id="float-单精度浮点型"><a href="#float-单精度浮点型" class="headerlink" title="float 单精度浮点型"></a>float 单精度浮点型</h4><pre><code>float f1 = 3.14f; //常在末尾加上f，表示单精度double f2 = 3.14; //在double中常省略</code></pre><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>字符型变量用于显示<strong>单个</strong>字符</p><pre><code>char ch = &apos;a&apos;; //单引号中只能有一个字母</code></pre><p>查看对应的ASCII码值</p><pre><code>cout &lt;&lt; (int)ch &lt;&lt; endl; //强制类型转换//A——65；a——97</code></pre><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><pre><code>\n  换行\t  水平制表符      和前面的总共构成8个空格，整齐地输出后面的内容\\  反斜杠字符</code></pre><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><pre><code>char str[] = &quot;hello world&quot;;string str2 = &quot;hello world&quot;; //两种创建方式    第二种方式要加头文件 #include &lt;string&gt;</code></pre><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><pre><code>/*true  （本质是数字1）false （本质是数字0）*/bool flag = true</code></pre><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>两个整数相除，结果依然为整数，直接舍弃小数（没有四舍五入）</p><pre><code>int a = 10;int b = 20;cout &lt;&lt; a/b &lt;&lt; endl //结果为0double d1 = 0.5;double d2 = 0.22;cout &lt;&lt; d1/d2 &lt;&lt; endl;   //2.27273</code></pre><h4 id="取模（取余）运算"><a href="#取模（取余）运算" class="headerlink" title="取模（取余）运算"></a>取模（取余）运算</h4><pre><code>%//小数不能做取模运算</code></pre><h4 id="递增"><a href="#递增" class="headerlink" title="递增"></a>递增</h4><pre><code>int a1 =10;int a2 = ++a1 * 10; //前置递增，先让变量+1，然后进行表达式的计算   a1=11,a2=110int b1 = 10;int b2 = b1++ *10; //后置递增，先进行表达式的计算，再让变量+1   b1=11,b2=100</code></pre><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><pre><code>// ！非    &amp;&amp;与   ||或</code></pre><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><pre><code>int a=10;int b=100;int c=0;c = ( a&lt;b ? a:b); //将较小值赋值给c//三目运算符返回的是变量，可以继续赋值（a&lt;b ? a:b) = 100;   //a=100</code></pre><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><pre><code>switch(表达式（变量）  字符型/整型){case1:case2:    、、、;  //1和2执行相同的语句    break;  //没有break，会一直执行后面的语句、、、default:    、、、;  //没有对应的case则执行default}</code></pre><h4 id="rand-生成伪随机整数"><a href="#rand-生成伪随机整数" class="headerlink" title="rand( )生成伪随机整数"></a>rand( )生成伪随机整数</h4><pre><code>//通用公式： a + rand()% n，a为起始整数，n为能取到的整数个数/*例如：[1,100]生成随机数：1+rand()%100;       (1,100]生成随机数：2+rand()%99;       (1,100)生成随机数：2+rand()%98;</code></pre><h4 id="srand-生成真随机数"><a href="#srand-生成真随机数" class="headerlink" title="srand( )生成真随机数"></a>srand( )生成真随机数</h4><pre><code>//根据当前系统时间生成随机数#include &lt;ctime&gt;srand((unsigned int)time(NULL));int a = 1+rand()%100;</code></pre><h4 id="取出各位上的数字"><a href="#取出各位上的数字" class="headerlink" title="取出各位上的数字"></a>取出各位上的数字</h4><pre><code>/*从多位数（例如：n=2456）取出各个位数上的数字个位：对10取模   int a = n%10;最高位：除以10的位数-1次方   int b = n/1000;其他位：除以10的对应次方，再对10取模  取出十位数字： int c = n/10%10;                                取出百位数字： int d = n/100%10;  间接变成取出个位数字 */                </code></pre><h4 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h4><pre><code>pow(10.0,3);   //10的3次方`</code></pre><h4 id="for循环的省略"><a href="#for循环的省略" class="headerlink" title="for循环的省略"></a>for循环的省略</h4><pre><code>//输出0到9所有整数int i = 0;    for(; ; ;){    if(i&gt;9)    {        break;    }    、、、;    i++;}</code></pre><p>for (   <strong><em>0</em></strong>int i=0;   <strong><em>1</em></strong> i&lt;10;  <strong><em>3</em></strong> i++)<br>{<br>        <strong><em>2</em></strong>、、、;<br>}      //执行顺序为0 1 2 3 1 2 3……..</p><h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>难点是在循环条件的书写，循环嵌套需要做的大体都是一个方形（可能不完整），行用 i 来控制，列用 j 来控制，且每一次 j 循环时 i 为定值，for( ) 循环常用计算需要循环的次数来确定循环条件，特别需要注意 j 关于 i 的通式的书写。</p><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><pre><code>//三种定义方式/*     数组类型 数组名[数组长度];    int a[4];    数组类型 数组名[数组长度] = {、、、}； int a[4]={1,2,3,4};    数组类型 数组名[] ={、、、};   int a[]={1,2,3,4};数组中每个元素类型相同数组名是首元素的地址，是个常量*/int arr[5]= {10,20,30,40,50};cout &lt;&lt; arr&lt;&lt;endl;     //输出为第一个元素地址   等同于 cout&lt;&lt; &amp;arr[0] &lt;&lt;endl;cout&lt;&lt;(int)arr&lt;&lt;endl;  //以十进制输出</code></pre><h4 id="删除数组中的一个元素"><a href="#删除数组中的一个元素" class="headerlink" title="删除数组中的一个元素"></a>删除数组中的一个元素</h4><pre><code>//遍历数组，如果某个元素和输入的相同，则删除该元素。可以分成两部分，第一个函数实现查找功能，变量a返回该元素在数组中的序号，没找到则返回-1//实现删除功能的函数接收返回变量，删除可以用后一个元素覆盖前一个来实现，for循环变量i从a开始到元素数（或者元素数-1）//最后数组元素数-1int is_exist(int* arr,int len){    for (int i = 0; i &lt; len; i++)    {        if (arr[i] == 6)        {            return i;        }    }    return -1;}   //一定要在for循环遍历整个数组发现没有该值后，再return -1</code></pre><h4 id="求数组元素个数"><a href="#求数组元素个数" class="headerlink" title="求数组元素个数"></a>求数组元素个数</h4><pre><code>int arr[]={1,2,3,4,5};int a = sizeof(arr)/sizeof(arr[0]);</code></pre><h4 id="数组前后依次交换元素值"><a href="#数组前后依次交换元素值" class="headerlink" title="数组前后依次交换元素值"></a>数组前后依次交换元素值</h4><pre><code>//从下标的角度思考，下标来移动，循环条件为 start &lt; endint arr[5]={1,2,3,4,5};int start =0; //首下标int end = sizeof(arr)/sizeof(arr[0])-1; //尾下标int a = 0;   //存储中间变量// 、、、、;</code></pre><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><pre><code>//6个数升序排列，进行5轮(外层循环 i=0，1，2，3，4)，每轮比较的次数n-i-1 (j的表达式)//输入回车开始排序#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void maopao(int* p, int len)       //冒泡排序{    for (int i = 0; i &lt; len - 1; i++)    {        for (int j = 0; j &lt; len - i - 1; j++)        {            if (p[j] &lt; p[j + 1])            {                int a = p[j];                p[j] = p[j + 1];                p[j + 1] = a;            }        }    }}int main(){    int i = 0;    int arr[20]  ;            //预先指定数组大小    while (cin.peek() != &apos;\n&apos;)         //键入回车跳出循环    {        cin &gt;&gt; arr[i];        i++;    }    int len = i;    cout &lt;&lt; i&lt;&lt;endl;    maopao(arr, len);    for (int j = 0; j &lt; len; j++)    {        cout &lt;&lt; arr[j] &lt;&lt; &quot; &quot;;    }    cout &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="数组作为参数传递给函数"><a href="#数组作为参数传递给函数" class="headerlink" title="数组作为参数传递给函数"></a>数组作为参数传递给函数</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void aaa(int arr[], int len)       //第一种方式 值传递{    for (int i = 0; i &lt; len; i++)    {        cout &lt;&lt; arr[i]&lt;&lt;&quot; &quot;;    }    cout &lt;&lt; endl;}int main(){    int arr[] = { 1,2,3,4,5 };    int len = sizeof(arr) / sizeof(arr[0]);    aaa(arr, len);    system(&quot;pause&quot;);    return 0;}#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void aaa(int *arr, int len)     //第二种方式 地址传递{    for (int i = 0; i &lt; len; i++)    {        cout &lt;&lt; arr[i]&lt;&lt;&quot; &quot;;    }    cout &lt;&lt; endl;}int main(){    int arr[] = { 1,2,3,4,5 };    int len = sizeof(arr) / sizeof(arr[0]);    aaa(arr, len);    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="二维数组名称"><a href="#二维数组名称" class="headerlink" title="二维数组名称"></a>二维数组名称</h4><pre><code>//查看内存空间int arr[2][3]= {{1,2,3},{4,5,6}}cout &lt;&lt; sizeof(arr) &lt;&lt;endl;    //数组占用的总内存空间cout &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; //第一行所占内存空间cout &lt;&lt; sizeof(arr)/sizeof(arr[0]);   //二维数组行数cout &lt;&lt; sizeof(arr[0])/sizeof([0][0]); //二维数组列数//首元素地址cout &lt;&lt; (int)arr &lt;&lt;endl; //数组首地址cout &lt;&lt; (int)arr[0] &lt;&lt;endl; //第一行首地址cout &lt;&lt; &amp;(int)arr[0][0] &lt;&lt; endl; //第一个元素首地址</code></pre><h4 id="二维数组加法"><a href="#二维数组加法" class="headerlink" title="二维数组加法"></a>二维数组加法</h4><p>做加法时，不要用arr[i] [j]+arr[i] [j+1]，而是</p><pre><code>int sum =0;//定义一个变量作为和for(int i=0;i&lt;、、、;i++){    for(int j=0;j&lt;、、、;j++)    {        sum +=arr[i][j];    }}</code></pre><h4 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h4><p>数组的每一个元素为一个字符串，且不要求长度相同</p><pre><code>string arr[3]={&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;};</code></pre><h4 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h4><pre><code>void test(int a,int b)        //形参接收实参时，int a=c,int b=d;{    cout&lt;&lt;a+b&lt;&lt;endl;}int main(){    int c=10;    int d=20;    test(c,d);    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="函数分文件编写"><a href="#函数分文件编写" class="headerlink" title="函数分文件编写"></a>函数分文件编写</h4><p>1、创建 .h 的头文件，在其中写函数声明</p><p>2、创建 .cpp 的源文件，在其中写函数的定义</p><p>.h文件</p><pre><code>#include&lt;iostream&gt;using namespace std;void swap(int a, int b);  //函数声明</code></pre><p>.cpp文件</p><pre><code>#include &quot;swap.h&quot;void swap(int a, int b)         //函数定义{    int c = a;    a = b;    b = c;    cout &lt;&lt; &quot;a的值为&quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b的值为&quot; &lt;&lt; b &lt;&lt; endl;}</code></pre><p>在主.cpp文件中再加上#include “swap.h” ，即可调用函数</p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><pre><code>int a=10;     //整型变量要定义整型int * p = &amp;a;  //p中存的是a的地址*p = 100;   //解引用，修改指针所指向的内存中的数据     a=100;//指针也是一种数据类型，表示为int *、float *等，变量名为p，和整型、字符型、字符串一样。sizeof(int *)，sizeof(p)。</code></pre><h4 id="指针常量和常量指针"><a href="#指针常量和常量指针" class="headerlink" title="指针常量和常量指针"></a>指针常量和常量指针</h4><pre><code>const int * p = &amp;a;  //常量指针    与int const *p = &amp;a完全相同*p =10; //错误    值只能读取，不能修改，防止误操作p = &amp;b; //正确const struct student *s;s-&gt;age = 18; //错误，结构体变量中的值不能修改int * const p = &amp;a;  //指针常量p = &amp;a; //错误*p = 10; //正确</code></pre><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p>形参的改变不影响实参的值</p><h4 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h4><p>用指针接收变量的地址，修改以后值会发生改变</p><p>结构体作为函数参数时，地址传递以指针来接收有利于减少内存空间</p><h4 id="指针-冒泡排序（升序）"><a href="#指针-冒泡排序（升序）" class="headerlink" title="指针+冒泡排序（升序）"></a>指针+冒泡排序（升序）</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void swap(int* p,int N){    int* p2 = p;    for (int i = 0; i &lt; N - 1; i++)    {        for (int j = 0; j &lt; N - i-1; j++)        {            if (*p2 &gt; * (p2 + 1))            {                int c = *p2;                *p2 = *(p2 + 1);                *(p2 + 1) = c;            }            p2++;        }        p2 =p;    }}int main(){    int arr[] = { 4,3,1,2,8,7,10,9,5,6 };    int N = sizeof(arr) / sizeof(arr[0]);    //数组长度    swap(arr,N);    for (int k = 0; k &lt; N; k++)    {        cout &lt;&lt; arr[k]&lt;&lt;&quot; &quot;&lt;&lt;endl;    }    system(&quot;pause&quot;);    return 0;}//指针的两种访问数组值的方式int *p =arr;cout &lt;&lt; p[2];int *p =arr;cout &lt;&lt; *(p+2);     //且这两种方式使用后并不改变 p 指向首地址#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void swap(int* p,int N){    for (int i = 0; i &lt; N - 1; i++)    {        for (int j = 0; j &lt; N - i-1; j++)        {            if (p[j] &gt;  p[j+1])            {                int c = p[j];                p[j] = p[j + 1];                p[j + 1] = c;            }        }    }}int main(){    int arr[] = { 4,3,1,2,8,7,10,9,5,6 };    int N = sizeof(arr) / sizeof(arr[0]);    swap(arr,N);    for (int k = 0; k &lt; N; k++)    {        cout &lt;&lt; arr[k]&lt;&lt;&quot; &quot;&lt;&lt;endl;    }    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><pre><code>struct student{    string name;    //姓名    int age;        //年龄    int score;        //分数};    //结构体定义   定义时struct关键字不可省略    定义好之后类似于一个数据类型，后面跟变量名可以直接赋值//结构体变量创建  struct关键字可省略student s1;s1.name = &quot;lalala&quot;;s1.age = 16;s1.score = 87;struct student s2={&quot;lalalala&quot;, 17, 98};</code></pre><h4 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h4><p>结构体定义没有区别，变量名变成了一个数组名，数组中的每个元素类型是一个结构体</p><pre><code>//创建结构体数组struct student arr[3]={    {&quot;张三&quot;,16,90},    {&quot;李四&quot;,18,70}，    {&quot;王五&quot;,19,80}}；arr[0].age =20;    //仍用变量名. 来访问，用for循环来遍历</code></pre><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><p>结构体定义没有区别</p><pre><code>//结构体变量创建struct student s ={&quot;张三&quot;, 17, 90};struct student *p = &amp;s;cout &lt;&lt; &quot;姓名：&quot;&lt;&lt; p-&gt;name &lt;&lt; endl;</code></pre><h4 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h4><pre><code>//定义struct student {    string name;    int age;    int score;}struct teacher{    int id;    string name;    struct student stu;}//创建变量struct teacher t;t.id = 1000;t.name = &quot;啦啦啦&quot;;t.stu.name =&quot;哦哦哦&quot;;t.stu.age = 17;t.stu.score =90;</code></pre><h4 id="结构体数组嵌套"><a href="#结构体数组嵌套" class="headerlink" title="结构体数组嵌套"></a>结构体数组嵌套</h4><p>三个老师每个人带三个学生</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student{    string name;    //姓名    int score;        //分数};struct teacher{    string name;    struct student arr[3];};int main(){    struct teacher arr1[3];     //难点    for (int k = 0; k &lt; 3; k++)    {        cout &lt;&lt; &quot;请输入第&quot;&lt;&lt;k+1&lt;&lt;&quot;个老师姓名：&quot; &lt;&lt; endl;        cin &gt;&gt; arr1[k].name;        for(int i=0;i&lt;3;i++)        {            cout &lt;&lt; &quot;请输入他第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;个学生的姓名&quot; &lt;&lt; endl;            cin &gt;&gt; arr1[k].arr[i].name;            cout &lt;&lt; &quot;请输入他第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;个学生的成绩&quot; &lt;&lt; endl;            cin &gt;&gt; arr1[k].arr[i].score;        }    }    for (int j = 0; j &lt; 3; j++)    {        cout &lt;&lt; &quot;第&quot; &lt;&lt; j + 1 &lt;&lt; &quot;个老师是：&quot; &lt;&lt; arr1[j].name &lt;&lt; endl;        for (int b = 0; b &lt; 3;b++)        {            cout &lt;&lt; &quot;他的第&quot; &lt;&lt; b + 1 &lt;&lt; &quot;个学生是：&quot; &lt;&lt;arr1[j].arr[b].name&lt;&lt; &quot;  &quot;             &lt;&lt; &quot;成绩为：&quot; &lt;&lt; arr1[j].arr[b].score &lt;&lt; endl;        }    }    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="根据某项元素对结构体数组排序"><a href="#根据某项元素对结构体数组排序" class="headerlink" title="根据某项元素对结构体数组排序"></a>根据某项元素对结构体数组排序</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct hero{    string name;    int age;    string gender;};void bubblesort(hero *arr, int len)       //按年龄对英雄排序{    for (int i = 0; i &lt; len-1; i++)        {            for (int j = 0; j &lt; len-1 - i; j++)            {                if (arr[j].age &gt; arr[j + 1].age)                {                    hero a = arr[j];                    arr[j] = arr[j + 1];                    arr[j + 1] = a;                }            }        }    for (int k = 0; k &lt; 5; k++)    {        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[k].name &lt;&lt; &quot; &quot; &lt;&lt; &quot;年龄&quot; &lt;&lt;    arr[k].age &lt;&lt; &quot; &quot; &lt;&lt; &quot;性别&quot; &lt;&lt; arr[k].gender &lt;&lt; endl;    }}int main(){    struct hero arr[] =    {        {&quot;刘备&quot;,23,&quot;男&quot;},        {&quot;关羽&quot;,22,&quot;男&quot;},        {&quot;张飞&quot;,20,&quot;男&quot;},        {&quot;赵云&quot;,21,&quot;男&quot;},        {&quot;貂蝉&quot;,19,&quot;女&quot;}    };           //五个数冒泡排序    int len = sizeof(arr) / sizeof(arr[0]);    bubblesort(arr, len);    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="无参数调用"><a href="#无参数调用" class="headerlink" title="无参数调用"></a>无参数调用</h4><pre><code>void showMenu(){    cout &lt;&lt; &quot;1、添加联系人&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;2、显示联系人&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;3、删除联系人&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;4、查找联系人&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;5、修改联系人&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;6、清空联系人&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;0、退出该系统&quot; &lt;&lt; endl;}int main(){    showMenu();        //括号不能省略    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="实例——通讯录管理系统"><a href="#实例——通讯录管理系统" class="headerlink" title="实例——通讯录管理系统"></a>实例——通讯录管理系统</h4><pre><code>#include&lt;iostream&gt;using namespace std;struct aaa           //联系人结构体{    string name;    string sex;    int age;    string phonenumber;    string address;};struct bbb        //通讯录结构体{    struct aaa arr[1000];    int size;    //当前通讯录中人员个数     };void showMenu(){    cout &lt;&lt; &quot;1、添加联系人&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;2、显示联系人&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;3、删除联系人&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;4、查找联系人&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;5、修改联系人&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;6、清空联系人&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;0、退出该系统&quot; &lt;&lt; endl;}void add_people(bbb *t){    int z = t-&gt;size;    cout &lt;&lt; &quot;请输入姓名：&quot; &lt;&lt; endl;    cin &gt;&gt; t-&gt;arr[z].name;    cout &lt;&lt; &quot;请输入性别：&quot; &lt;&lt; endl;    cin &gt;&gt; t-&gt;arr[z].sex;    cout &lt;&lt; &quot;请输入年龄：&quot;&lt;&lt;endl;    cin &gt;&gt; t-&gt;arr[z].age;    cout &lt;&lt; &quot;请输入电话：&quot; &lt;&lt; endl;    cin &gt;&gt; t-&gt;arr[z].phonenumber;    cout &lt;&lt; &quot;请输入地址：&quot; &lt;&lt; endl;    cin &gt;&gt; t-&gt;arr[z].address;    t-&gt;size++;}void show_people(bbb t){    if (t.size == 0)    {        cout &lt;&lt; &quot;当前联系人为空&quot; &lt;&lt; endl;    }    else    {        for (int i = 0; i &lt; t.size; i++)        {            cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; t.arr[i].name &lt;&lt; &quot; &quot; &lt;&lt; &quot;性别：&quot; &lt;&lt; t.arr[i].sex &lt;&lt; &quot; &quot; &lt;&lt; &quot;年龄：&quot; &lt;&lt; t.arr[i].age                &lt;&lt; &quot; &quot; &lt;&lt; &quot;电话：&quot; &lt;&lt; t.arr[i].phonenumber &lt;&lt; &quot; &quot; &lt;&lt; &quot;地址：&quot; &lt;&lt; t.arr[i].address &lt;&lt; endl;        }    }}int is_exist(bbb* t, string name){    int i = 0;    for (; i &lt; t-&gt;size; i++)    {        if (t-&gt;arr[i].name == name)        {            return i;        }    }    return -1;}       //多个功能都涉及到查找，返回数组元素下标void delete_people(bbb* t){    string name;    cout &lt;&lt; &quot;请输入想要删除的联系人姓名：&quot;;    cin &gt;&gt; name;    int a = is_exist(t, name);    if (a == -1)    {        cout &lt;&lt; &quot;查无此人！&quot; &lt;&lt; endl;    }    else    {        for (int i = a; i &lt; t-&gt;size; i++)        {            t-&gt;arr[i] = t-&gt;arr[i + 1];        }        t-&gt;size--;    }}void find_people(bbb *t){    string name;    cout &lt;&lt; &quot;请输入想查找的联系人：&quot; &lt;&lt; endl;    cin &gt;&gt; name;    int a = is_exist(t, name);    if (a == -1)    {        cout &lt;&lt; &quot;查无此人！&quot; &lt;&lt; endl;    }    else    {        cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;t-&gt;arr[a].name&lt;&lt;&quot; &quot; &lt;&lt; &quot;性别：&quot; &lt;&lt; t-&gt;arr[a].sex &lt;&lt; &quot; &quot; &lt;&lt; &quot;年龄：&quot; &lt;&lt; t-&gt;arr[a].age            &lt;&lt; &quot; &quot; &lt;&lt; &quot;电话：&quot; &lt;&lt; t-&gt;arr[a].phonenumber &lt;&lt; &quot; &quot; &lt;&lt; &quot;地址：&quot; &lt;&lt; t-&gt;arr[a].address &lt;&lt; endl;    }}void modify_people(bbb *t){    string name;    cout &lt;&lt; &quot;请输入想修改的联系人姓名：&quot; &lt;&lt; endl;    cin &gt;&gt; name;    int a = is_exist(t, name);    if (a == -1)    {        cout &lt;&lt; &quot;查无此人！&quot; &lt;&lt; endl;    }    else    {        cout &lt;&lt; &quot;请重新输入姓名：&quot; &lt;&lt; endl;        cin &gt;&gt; t-&gt;arr[a].name;        cout &lt;&lt; &quot;请输入性别&quot; &lt;&lt; endl;        cin &gt;&gt; t-&gt;arr[a].sex;        cout &lt;&lt; &quot;请输入年龄&quot; &lt;&lt; endl;        cin &gt;&gt; t-&gt;arr[a].age;        cout &lt;&lt; &quot;请输入电话：&quot; &lt;&lt; endl;        cin &gt;&gt; t-&gt;arr[a].phonenumber;        cout &lt;&lt; &quot;请输入地址&quot; &lt;&lt; endl;        cin &gt;&gt; t-&gt;arr[a].address;    }}void clean_out(bbb* t){    cout &lt;&lt; &quot;您是否确认要清空通讯录  1——是   2——否&quot; &lt;&lt; endl;    int s;    cin &gt;&gt; s;    if (s == 1)    {        t-&gt;size = 0;        cout &lt;&lt; &quot;通讯录已清空！&quot; &lt;&lt; endl;    }}int main(){    struct bbb  t;    t.size = 0;    int select;    while (1)    {        showMenu();        cin &gt;&gt; select;        string abc;        switch (select)        {        case 1:            add_people(&amp;t);            break;        case 2:            show_people(t);            break;        case 3:            delete_people(&amp;t);            break;        case 4:            find_people(&amp;t);            break;        case 5:            modify_people(&amp;t);            break;        case 6:            clean_out(&amp;t);            break;        case 0:            cout &lt;&lt; &quot;再见！&quot; &lt;&lt; endl;            system(&quot;pause&quot;);            return 0;        default:            break;        }        system(&quot;pause&quot;);        system(&quot;cls&quot;);    }    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="变量（常量）都在哪"><a href="#变量（常量）都在哪" class="headerlink" title="变量（常量）都在哪"></a>变量（常量）都在哪</h4><pre><code>const int c_g_a=10;   //const修饰的全局变量——全局常量——全局区int g_a=10;    //全局变量——全局区int main(){    int l_a=10;   //局部变量——非全局区（栈区）    static a=10;   //静态变量——全局区    &quot;hello&quot;;   //字符串常量——全局区    const int c_l_a=10;   //const修饰的局部变量——局部常量——非全局区（栈区）    system(&quot;pause&quot;);    return 0;}//栈区数据（局部变量和形参）由编译器管理开辟和释放，该函数执行完自动释放，故不要返回局部变量的地址</code></pre><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><pre><code>//由程序员管理开辟和释放int * func(){    int * p = new int(10);       //该指针是局部变量，存放在栈区，指针中地址存放的数在堆区，new将数据开辟到堆区，返回其地址    return p;}int main(){    int *p =func();    cout&lt;&lt;*p&lt;&lt;endl;    delete p;   //释放}</code></pre><h4 id="堆区创建数组"><a href="#堆区创建数组" class="headerlink" title="堆区创建数组"></a>堆区创建数组</h4><pre><code>int* func(){    int *p = new int[5];    for(int i=0;i&lt;5;i++)    {        cin&gt;&gt;p[i];    }    return p;}int main(){    int *arr=func();    for(int j=0;j&lt;5;j++)    {        cout&lt;&lt;arr[j];    }    cout&lt;&lt;endl;    delete[] arr;    //释放堆区的数组，且不是delete[] p    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><pre><code>//引用必须初始化，且之后不可改变int a=10;int &amp;b=a;      //引用的本质是指针常量 int *const b=&amp;a;    b中存放的始终是a的地址，且可以通过*b去改变a的值</code></pre><h4 id="引用做函数参数-形参"><a href="#引用做函数参数-形参" class="headerlink" title="引用做函数参数(形参)"></a>引用做函数参数(形参)</h4><pre><code>//以引用的方式接收实参，让形参可以修饰实参void exchange(int &amp;a, int &amp;b)     {    int c = a;    a = b;    b = c;}int main(){    int a = 10;    int b = 20;    exchange(a, b);             //int &amp;a=a;   别名也叫a    cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;       //a=20,b=10    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="引用做返回值"><a href="#引用做返回值" class="headerlink" title="引用做返回值"></a>引用做返回值</h4><pre><code>int&amp; test(){    static int a = 10;    return a;             //返回a的引用，才能用别名去接收，且不要返回局部变量的引用}int main(){    int &amp;b = test();      //b是a的引用    test() = 1000;        //函数做左值，则必须返回引用；对原名进行操纵    cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;    //别名的值也会改变                                  //b=1000    system(&quot;pause&quot;);    return 0;}//错误案例int test(){    static int a = 10;    return a;}int main(){    test() = 1000;       //返回原值，函数不能直接做左值    //cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h4><pre><code>void test(const int &amp;b)       {    //b=40;   错误的，不允许通过别名再修改 const int &amp;b=30,只给只读权限，防止误操作    cout &lt;&lt; &quot;b=&quot; &lt;&lt; b&lt;&lt;endl;}int main(){    int a = 30;    test(a);    system(&quot;pause&quot;);    return 0;}//cont int &amp;b=30  相当于int a=30;     const int &amp;b=a;</code></pre><h4 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h4><pre><code>void test(int a,int b,int c);     //函数的声明和实现只能有一个有默认参数void test(int a, int b = 10, int c = 30)    //默认参数必须放在最后，就是有默认参数的形参右侧的形参必须都有默认参数{    cout &lt;&lt; a + b + c &lt;&lt; endl;}int main(){    test(10, 20);      //使用用户提供的值，10+20+30    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h4><pre><code>//二者唯一的区别是结构体在默认情况下成员是公共的，类在默认情况下成员是私有的（但是都可以自定义）#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student                  //学生结构体{    string name;    string number;    void show()    {        cout &lt;&lt; &quot;姓名为：&quot; &lt;&lt; name &lt;&lt; endl;        cout &lt;&lt; &quot;学号为：&quot; &lt;&lt; number &lt;&lt; endl;    }};int main(){    student s1;    s1.name = &quot;张三&quot;;    s1.number = &quot;123456&quot;;    s1.show();    system(&quot;pause&quot;);    return 0;}#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class student                //学生类{public:    string name;    string number;             //两个属性：姓名和学号    void show()                   //行为：打印出姓名和学号    {        cout &lt;&lt; &quot;姓名为：&quot; &lt;&lt; name &lt;&lt; endl;        cout &lt;&lt; &quot;学号为：&quot; &lt;&lt; number &lt;&lt; endl;    }};int main(){    student s1;           //通过类创建出一个具体的学生    s1.name = &quot;张三&quot;;    s1.number = &quot;123456&quot;;    s1.show();    system(&quot;pause&quot;);    return 0;}//构造一个类，相当于一个新的数据类型，它下面又包含一系列基本数据类型（int/string能存在的地方，它基本都能在）</code></pre><h4 id="类成员的访问权限"><a href="#类成员的访问权限" class="headerlink" title="类成员的访问权限"></a>类成员的访问权限</h4><p>1、public</p><p>类内可访问、类外可访问</p><p>2、protected</p><p>类内可访问、类外不可访问，继承该类的子类可以访问</p><p>3、private</p><p>类内可访问、类外不可访问，继承该类的子类不可访问</p><h4 id="中途退出函数"><a href="#中途退出函数" class="headerlink" title="中途退出函数"></a>中途退出函数</h4><pre><code>//函数遇到return关键字会直接退出，不再执行剩下的语句void test(int age){    if(age&lt;0 || age&gt;150)    {        cout&lt;&lt;&quot;输入有误！&quot;&lt;&lt;endl;        return;         //直接退出函数    }    else    {        //、、、;    }    //、、、;}</code></pre><h4 id="成员函数和全局函数"><a href="#成员函数和全局函数" class="headerlink" title="成员函数和全局函数"></a>成员函数和全局函数</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class cube //学生结构体{public:    //设置长    void set_l(double l)       //成员函数（行为）    {        m_l = l;    }    //获取长    double get_l()    {        return m_l;    }    //设置宽    void set_w(double w)    {        m_w = w;    }    //获取宽    double get_w()    {        return m_w;    }    //设置高    void set_h(double h)    {        m_h= h;    }    //获取高    double get_h()    {        return m_h;    }    //获得表面积    double get_square()    {        double square = (m_l * m_h + m_l * m_w + m_h * m_w) * 2;        return square;    }    //获得体积    double get_volume()    {        double volume = m_l * m_h * m_w;        return volume;    }    //利用成员函数比较两个立方体是否完全相同    bool panduan(cube &amp;c)    {        if (m_l == c.get_l() &amp;&amp; m_h == c.get_h() &amp;&amp; m_w == c.get_w())        {            return true;        }        else        {            return false;        }    }private:    double m_l;         //成员变量（属性）    double m_w;    double m_h;};//全局函数判断是否相等bool issame(cube &amp;c1,cube &amp;c2){    if (c1.get_l() == c2.get_l() &amp;&amp; c1.get_h()== c2.get_h() &amp;&amp; c1.get_w() == c2.get_w())    {        return true;    }    else    {        return false;    }}int main(){    cube c1;         //定义对象    c1.set_l(2.0);    c1.set_w(3.0);    c1.set_h(4.0);    double s = c1.get_square();//表面积    cout &lt;&lt; &quot;表面积为：&quot; &lt;&lt; s &lt;&lt; endl;    double v = c1.get_volume();    cout &lt;&lt; &quot;体积为：&quot; &lt;&lt; v &lt;&lt; endl;    cube c2;    c2.set_l(2.0);    c2.set_w(3.0);    c2.set_h(3.0);    bool b = issame(c1, c2);    if (b)    {        cout &lt;&lt; &quot;两个立方体完全相同&quot; &lt;&lt; endl;    }    else     {        cout &lt;&lt; &quot;两个立方体不相同&quot; &lt;&lt; endl;    }    bool d = c1.panduan(c2);      //关键点，c1结构体去调用函数，传入参数为c2，比较c1和c2的长、宽、高    cout &lt;&lt; d;    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="类的嵌套"><a href="#类的嵌套" class="headerlink" title="类的嵌套"></a>类的嵌套</h4><pre><code>//判断点和圆的位置关系#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Point{public:    //设置点x坐标    void set_p_x(int x)    {        p_x = x;    }    //设置点y坐标    void set_p_y(int y)    {        p_y = y;    }    //获取点x坐标    int get_p_x()    {        return p_x;    }    //获取点y坐标    int get_p_y()    {        return p_y;    }private:    int p_x;   //点x坐标    int p_y;   //点y坐标};class Circle       //圆类{public:    //设置圆心坐标    void set_c_p(Point p)    {        c_p = p;    }    //获取圆心    Point get_c_p()    {        return c_p;    }    //设置半径    void set_r(int r)    {        c_r = r;    }    //获取半径    int get_r()    {        return c_r;    }private:    Point c_p; //圆心坐标    int c_r;    //半径};//全局函数确定点和圆的位置关系void panduan(Circle&amp; c, Point&amp; p){    int c_x = c.get_c_p().get_p_x();  // 圆心x    int c_y = c.get_c_p().get_p_y();//圆心y    int r = c.get_r(); //半径    int p_x = p.get_p_x();    int p_y = p.get_p_y();    int d2 = (c_x - p_x) * (c_x - p_x) + (c_y - p_y) * (c_y - p_y);    if (d2 == (r*r))    {        cout &lt;&lt; &quot;点在圆上&quot; &lt;&lt; endl;    }    else if (d2 &lt; (c.get_r() * c.get_r()))    {        cout &lt;&lt; &quot;点在圆内&quot; &lt;&lt; endl;    }    else    {        cout &lt;&lt; &quot;点在圆外&quot; &lt;&lt; endl;    }}int main(){    Point p;   //点    p.set_p_x(3);    p.set_p_y(0);    Circle c;    //圆    c.set_r(3);    Point c_p;    c_p.set_p_x(0);    c_p.set_p_y(0);    c.set_c_p(c_p);    panduan(c, p);    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="分文件编写"><a href="#分文件编写" class="headerlink" title="分文件编写"></a>分文件编写</h4><pre><code>//circle.h#pragma once#include&lt;iostream&gt;#include&lt;string&gt;#include&quot;point.h&quot;using namespace std;class Circle       //圆类{public:    //设置圆心坐标        //只保留函数声明和成员声明    void set_c_p(Point p);    //获取圆心    Point get_c_p();    //设置半径    void set_r(int r);    //获取半径    int get_r();private:    Point c_p; //圆心坐标    int c_r;    //半径};//circle.cpp#include &quot;circle.h&quot;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//设置圆心坐标void Circle::set_c_p(Point p)     //函数作用域 Circle类下{    c_p = p;}//获取圆心Point Circle::get_c_p(){    return c_p;}//设置半径void Circle::set_r(int r){    c_r = r;}//获取半径int Circle::get_r(){    return c_r;}//point.h#pragma once#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Point{public:    //设置点x坐标    void set_p_x(int x);    //设置点y坐标    void set_p_y(int y);    //获取点x坐标    int get_p_x();    //获取点y坐标    int get_p_y();private:    int p_x;   //点x坐标    int p_y;   //点y坐标};//point.cpp#include &quot;point.h&quot;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//设置点x坐标void Point::set_p_x(int x){    p_x = x;}//设置点y坐标void Point::set_p_y(int y){    p_y = y;}//获取点x坐标int Point::get_p_x(){    return p_x;}//获取点y坐标int Point::get_p_y(){    return p_y;}//主程序#include&lt;iostream&gt;#include&lt;string&gt;#include&quot;circle.h&quot;#include&quot;point.h&quot;using namespace std;//全局函数确定点和圆的位置关系void panduan(Circle&amp; c, Point&amp; p){    int c_x = c.get_c_p().get_p_x();  // 圆心x    int c_y = c.get_c_p().get_p_y();//圆心y    int r = c.get_r(); //半径    int p_x = p.get_p_x();    int p_y = p.get_p_y();    int d2 = (c_x - p_x) * (c_x - p_x) + (c_y - p_y) * (c_y - p_y);    if (d2 == (r*r))    {        cout &lt;&lt; &quot;点在圆上&quot; &lt;&lt; endl;    }    else if (d2 &lt; (c.get_r() * c.get_r()))    {        cout &lt;&lt; &quot;点在圆内&quot; &lt;&lt; endl;    }    else    {        cout &lt;&lt; &quot;点在圆外&quot; &lt;&lt; endl;    }}int main(){    Point p;   //点    p.set_p_x(3);    p.set_p_y(0);    Circle c;    //圆    c.set_r(3);    Point c_p;    c_p.set_p_x(0);    c_p.set_p_y(0);    c.set_c_p(c_p);    panduan(c, p);    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="构造函数什么时候被调用"><a href="#构造函数什么时候被调用" class="headerlink" title="构造函数什么时候被调用"></a>构造函数什么时候被调用</h4><pre><code>//构造函数调用测试#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Point       //创建一个类，会自动生成 默认构造、默认析构、拷贝构造（值拷贝）三个函数{public:         Point()    {        cout &lt;&lt; &quot;默认构造调用&quot; &lt;&lt; endl;    }    Point(int a,int b)       //写了有参构造函数，则编译器不再提供默认构造函数，会提供拷贝构造函数    {                         //写了拷贝构造函数，则编译器不再提供其他构造函数        p_x = a;        p_y = b;        cout &lt;&lt; &quot;有参构造调用&quot; &lt;&lt; endl;    }    Point(const Point&amp; a)    {        p_x = a.p_x;        p_y = a.p_y;        cout &lt;&lt; &quot;拷贝构造调用&quot; &lt;&lt; endl;    }    ~Point()    {                       //析构函数，将堆区（程序员自己开辟）数据释放        cout &lt;&lt; &quot;默认析构调用&quot; &lt;&lt; endl;    }    int p_x;   //点x坐标    int p_y;};void test(){    Point p;      //会调用默认构造    Point b(0,2);  //调用有参构造    cout &lt;&lt; &quot;b的横坐标为&quot; &lt;&lt; b.p_x &lt;&lt; endl;    cout &lt;&lt; &quot;b的纵坐标为&quot; &lt;&lt; b.p_y &lt;&lt; endl;    Point a(b);   //调用拷贝构造    cout &lt;&lt; &quot;a的横坐标为&quot; &lt;&lt; a.p_x &lt;&lt; endl;    cout &lt;&lt; &quot;a的纵坐标为&quot; &lt;&lt; a.p_y &lt;&lt; endl;}int main(){    test();   //执行完后会调用默认析构    system(&quot;pause&quot;);    return 0;}/*运行结果为：默认构造调用有参构造调用b的横坐标为0b的纵坐标为2拷贝构造调用a的横坐标为0a的纵坐标为2默认析构调用默认析构调用默认析构调用请按任意键继续. . .*/</code></pre><h4 id="析构函数执行堆区数据的释放"><a href="#析构函数执行堆区数据的释放" class="headerlink" title="析构函数执行堆区数据的释放"></a>析构函数执行堆区数据的释放</h4><pre><code>//构造函数调用测试#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Point      {public:         Point()    {        cout &lt;&lt; &quot;默认构造调用&quot; &lt;&lt; endl;    }    Point(int a)    {        p_x = a;        p_y = new int(2);     //创建在堆区，由指针去接收        cout &lt;&lt; &quot;有参构造调用&quot; &lt;&lt; endl;    }    ~Point()    {        if (p_y != NULL)    //指针不指向空，则释放堆区数据        {            delete p_y;            p_y = NULL;        }        cout &lt;&lt; &quot;默认析构调用&quot; &lt;&lt; endl;    }    int p_x;   //点x坐标    int *p_y;};void test(){    Point p;      //会调用默认构造    Point b(0);  //调用有参构造    cout &lt;&lt; &quot;b的横坐标为&quot; &lt;&lt; b.p_x &lt;&lt; endl;    cout &lt;&lt; &quot;b的纵坐标为&quot; &lt;&lt; *b.p_y &lt;&lt; endl;}int main(){    test();   //执行完后会调用默认析构    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="浅拷贝的问题"><a href="#浅拷贝的问题" class="headerlink" title="浅拷贝的问题"></a>浅拷贝的问题</h4><pre><code>//浅拷贝带来的问题#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Point      {public:         Point()    {        cout &lt;&lt; &quot;默认构造调用&quot; &lt;&lt; endl;    }    Point(int a)    {        p_x = a;        p_y = new int(2);     //创建在堆区        cout &lt;&lt; &quot;有参构造调用&quot; &lt;&lt; endl;    }    Point(const Point&amp; a)    {        p_x = a.p_x;        p_y = a.p_y;       //指向同一块堆区内存        cout &lt;&lt; &quot;拷贝构造调用&quot; &lt;&lt; endl;    }    ~Point()    {        if (p_y != NULL)        {            delete p_y;            p_y = NULL;        }        cout &lt;&lt; &quot;默认析构调用&quot; &lt;&lt; endl;    }    int p_x;   //点x坐标    int *p_y;};void test(){    Point p;      //会调用默认构造    Point b(0);  //调用有参构造    cout &lt;&lt; &quot;b的横坐标为&quot; &lt;&lt; b.p_x &lt;&lt; endl;    cout &lt;&lt; &quot;b的纵坐标为&quot; &lt;&lt; *b.p_y &lt;&lt; endl;    Point a(b);          //浅拷贝    cout &lt;&lt; &quot;a的横坐标为&quot; &lt;&lt; a.p_x &lt;&lt; endl;    cout &lt;&lt; &quot;a的纵坐标为&quot; &lt;&lt; *a.p_y &lt;&lt; endl;         //Point a 后定义，但是先被释放，执行析构函数，堆区数据被释放；同样b也会执行相同操作，同一块内存被释放两次，引起错误}int main(){    test();   //执行完后会调用默认析构    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="深拷贝解决堆区重复释放的问题"><a href="#深拷贝解决堆区重复释放的问题" class="headerlink" title="深拷贝解决堆区重复释放的问题"></a>深拷贝解决堆区重复释放的问题</h4><pre><code>//深拷贝测试#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Point      {public:         Point()    {        cout &lt;&lt; &quot;默认构造调用&quot; &lt;&lt; endl;    }    Point(int a)         //有参构造    {        p_x = a;        p_y = new int(2);     //创建在堆区        cout &lt;&lt; &quot;有参构造调用&quot; &lt;&lt; endl;    }    Point(const Point&amp; a)    {        p_x = a.p_x;        //编译器默认的浅拷贝 p_y = a.p_y;        p_y = new int(*a.p_y);     //指针解引用，重新开辟堆区内存——深拷贝        cout &lt;&lt; &quot;拷贝构造调用&quot; &lt;&lt; endl;    }    ~Point()    {        if (p_y != NULL)        {            delete p_y;            p_y = NULL;        }        cout &lt;&lt; &quot;默认析构调用&quot; &lt;&lt; endl;    }    int p_x;   //点x坐标    int *p_y;};void test(){    Point p;      //会调用默认构造    Point b(0);  //调用有参构造    cout &lt;&lt; &quot;b的横坐标为&quot; &lt;&lt; b.p_x &lt;&lt; endl;    cout &lt;&lt; &quot;b的纵坐标为&quot; &lt;&lt; *b.p_y &lt;&lt; endl;    Point a(b);    cout &lt;&lt; &quot;a的横坐标为&quot; &lt;&lt; a.p_x &lt;&lt; endl;    cout &lt;&lt; &quot;a的纵坐标为&quot; &lt;&lt; *a.p_y &lt;&lt; endl;    //执行各自的析构函数，不再报错}int main(){    test();   //执行完后会调用默认析构    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><pre><code>//通过初始化列表给类属性赋值#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Phone{public:    Phone(string name)     //有参构造    {        p_name = name;    }    string p_name;};class Student{public:    Student(string name,int age,Phone phone):s_name(name),s_age(age),s_phone(phone)     //初始化列表    {    }    string s_name;    int s_age;    Phone s_phone;     //类的嵌套（一个类作为另一个类的成员变量）};void test(){    Phone p(&quot;SAMSUNG&quot;);        Student s(&quot;张三&quot;, 18, p);    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; s.s_name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; s.s_age &lt;&lt; &quot; 手机品牌:&quot; &lt;&lt; s.s_phone.p_name &lt;&lt; endl;}int main(){    test();    system(&quot;pause&quot;);    return 0;}//构造时，先构造Phone（内层），再构造Student（外层）,析构的顺序与之相反</code></pre><h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><p>1、所有对象共享同一份数据</p><p>2、编译阶段就分配内存</p><p>3、类内声明，内外初始化</p><h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><p>1、通过对象来访问</p><p>2、通过类名来访问</p><p>3、只能访问静态成员变量</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Point{public:    static void function()    {        cout &lt;&lt; &quot;lalall&quot; &lt;&lt; endl;        a = 100;    //静态成员函数只能访问静态成员变量   非静态成员函数、静态成员函数和静态成员变量，不属于类的对象上，大家共享一份（只有非静态成员变量属于类的对象上）    }    static int a;};int Point::a = 0;         //静态成员变量，类内声明，类外初始化void test(){    Point p;    p.function();     //通过对象访问    Point::function();  //通过类名访问，只有静态成员函数可以，是所有对象共享一份成员函数的体现}int main(){    test();   //执行完后会调用默认析构    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="只有非静态成员变量属于类的对象上"><a href="#只有非静态成员变量属于类的对象上" class="headerlink" title="只有非静态成员变量属于类的对象上"></a>只有非静态成员变量属于类的对象上</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Point{    int a;    int b;};void test(){    Point p;    cout &lt;&lt; sizeof(p) &lt;&lt; endl;        //8}int main(){    test();   //执行完后会调用默认析构    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="成员变量和形参名称冲突-this指针"><a href="#成员变量和形参名称冲突-this指针" class="headerlink" title="成员变量和形参名称冲突   this指针"></a>成员变量和形参名称冲突   this指针</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Point{public:    Point(int a)    {        a = a;  //和成员变量a无关  ，修改方式：1、改名称  2、this-&gt;a=a;    this指针指向成员函数被调用的对象（该处为p）        //cout &lt;&lt; a &lt;&lt; endl;    }    int a;};void test(){    Point p(2);    cout &lt;&lt; p.a &lt;&lt; endl;    //乱码}int main(){    test();   //执行完后会调用默认析构    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="this返回该对象"><a href="#this返回该对象" class="headerlink" title="*this返回该对象"></a>*this返回该对象</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Point{public:    Point(int a)    {        this-&gt;a = a;     }    Point&amp; ptop(Point&amp; p)     //返回类的引用，    如果返回值的话（Point），会新创建类，不再是p2    {        this-&gt;a += p.a;        return *this;    }        int a;};void test1(){    Point p1(10);    Point p2(10);    p2.ptop(p1).ptop(p1).ptop(p1);    //链式编程    cout &lt;&lt; p2.a &lt;&lt; endl;}int main(){    test1();    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="this-指针本质是指针常量"><a href="#this-指针本质是指针常量" class="headerlink" title="this 指针本质是指针常量"></a>this 指针本质是指针常量</h4><p>P *const this  即this是指向P的一个指针常量</p><pre><code>//指针常量 int * const p = &amp;a;  p=&amp;b表达式是错误的，*p = 20是允许的 故：//P *const this  即this是指向P的一个指针常量class P{public:    P(int a)    {        this-&gt;m_a=a;    //指针常量所指向的内存地址的值是可以修改的        //this =NULL;  //所指向的内存地址是不允许修改的    }    int m_a;};</code></pre><h4 id="成员函数后加const-常函数"><a href="#成员函数后加const-常函数" class="headerlink" title="成员函数后加const 常函数"></a>成员函数后加const 常函数</h4><pre><code>class Point{public:    void print_a(int a) const      //常函数，const修饰this指针，this指向内存的值不允许修改    {        //this-&gt;m_a = a;         this -&gt;m_b = 100;     //允许，mutable定义特殊变量，允许修改        cout &lt;&lt; m_a &lt;&lt; endl;    }    int m_a;    mutable int m_b;};void test(){    const Point p;    //常对象    常对象只能调用常函数，不能调用普通的成员函数    //p.m_a = 100;   不允许修改    p.m_b=100;   //允许}int main(){    test();    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="构造和析构函数上不允许使用类型限定符（如const）"><a href="#构造和析构函数上不允许使用类型限定符（如const）" class="headerlink" title="构造和析构函数上不允许使用类型限定符（如const）"></a>构造和析构函数上不允许使用类型限定符（如const）</h4><h4 id="友元（可以访问类中的私有成员）"><a href="#友元（可以访问类中的私有成员）" class="headerlink" title="友元（可以访问类中的私有成员）"></a>友元（可以访问类中的私有成员）</h4><h5 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h5><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Building{    friend void test(Building* building);   //全局函数做友元，可以访问私有成员public:    Building()    {        m_s = &quot;啦啦啦啦&quot;;        m_b = &quot;不不不不不不&quot;;    }    string m_s;private:    string m_b;};void test(Building* building){    string a = building-&gt;m_s;    cout &lt;&lt; a &lt;&lt; endl;    string b = building-&gt;m_b;    cout &lt;&lt; b &lt;&lt; endl;}int  main(){    Building building;    //默认构造    test(&amp;building);    system(&quot;pause&quot;);    return 0;}</code></pre><h5 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h5><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Building{    friend class goodguy;   //goodguy类做友元public:    Building();    string m_s;private:    string m_b;};class goodguy{public:    void visit();    Building building;   //类的嵌套};Building::Building()     //类外写成员函数（构造函数）{    m_s = &quot;lallalal&quot;;    m_b = &quot;bbbbbbb&quot;;}void goodguy::visit(){    cout &lt;&lt; building.m_s &lt;&lt; endl;    cout &lt;&lt; building.m_b &lt;&lt; endl;}int  main(){    goodguy guy;    guy.visit();    system(&quot;pause&quot;);    return 0;}//不用类的嵌套#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Building{    friend class goodguy; //类做友元public:    Building();  //构造函数声明，类外实现    string m_s;private:    string m_b;};class goodguy{public:    goodguy();    void visit();    Building* building; //指针};Building::Building(){    m_s = &quot;lallalal&quot;;    m_b = &quot;bbbbbbb&quot;;}goodguy::goodguy()      //构造函数实现{    building  = new Building;     //堆区开辟一个Building，赋给指针building}void goodguy::visit(){    cout &lt;&lt; building-&gt;m_s &lt;&lt; endl;    cout &lt;&lt; building-&gt;m_b &lt;&lt; endl;}int  main(){    goodguy guy;    guy.visit();    system(&quot;pause&quot;);    return 0;}</code></pre><h5 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h5><pre><code>//（类中的某个成员函数做友元）#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Building;class goodguy        //要把该类写在Building类前面，否则第x行还是会报错{public:    goodguy();    void visit();    void visit2();    Building* building;};class Building{    friend void goodguy::visit();public:    Building();    string m_s;private:    string m_b;};Building::Building(){    m_s = &quot;lallalal&quot;;    m_b = &quot;bbbbbbb&quot;;}goodguy::goodguy(){    building  = new Building;}void goodguy::visit(){    cout &lt;&lt; building-&gt;m_s &lt;&lt; endl;    cout &lt;&lt; building-&gt;m_b &lt;&lt; endl;    //第x行}void goodguy::visit2(){    cout &lt;&lt; building-&gt;m_s &lt;&lt; endl;}int  main(){    goodguy guy;    guy.visit();    guy.visit2();    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="运算符重载（加法）"><a href="#运算符重载（加法）" class="headerlink" title="运算符重载（加法）"></a>运算符重载（加法）</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person{public:    Person operator+(Person&amp; a);         //重载运算符-也是类似    int m_a;    int m_b;};Person Person::operator+(Person&amp; a)      //成员函数重载+号{    Person c;    c.m_a = this-&gt;m_a + a.m_a;    c.m_b = this-&gt;m_b + a.m_b;    return c;}//Person operator+(Person&amp; a, Person&amp; b)   //全局函数重载+号//{//    Person c;//    c.m_a = a.m_a + b.m_a;//    c.m_b = a.m_b + b.m_b;//    return c;//}Person operator+(Person &amp;a,int b)      //函数重载，函数名相同，但是参数不同{    Person c;    c.m_a = a.m_a + b;    c.m_b = a.m_b + b;    return c;}void test(){    Person a;    a.m_a = 10;    a.m_b = 20;    Person b;    b.m_a = 10;    b.m_b = 20;    Person c = a + b;     //本质上是     Person c = a.operator+(b);      Person c = operator+(a,b)    cout &lt;&lt; c.m_a &lt;&lt; endl;    cout &lt;&lt; c.m_b &lt;&lt; endl;    Person d = a+10;      //Person + int    cout&lt;&lt;d.m_a&lt;&lt;endl;     //20    cout&lt;&lt;d.m_b&lt;&lt;endl;     //30}int  main(){    test();    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="运算符重载（左移运算符）"><a href="#运算符重载（左移运算符）" class="headerlink" title="运算符重载（左移运算符）"></a>运算符重载（左移运算符）</h4><pre><code>//（直接输出类的成员变量的值）#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person{public:    Person(int a, int b)     //有参构造函数可以解决私有成员访问问题    {        m_a = a;        m_b = b;    }    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person a);private:    int m_a;    int m_b;};ostream&amp; operator&lt;&lt;(ostream &amp;cout, Person a)    //cout 数据类型为标准输出流ostream,且cout唯一所以要用引用{    cout &lt;&lt; a.m_a &lt;&lt; &quot; &quot; &lt;&lt; a.m_b;    return cout;}void test(){    Person a(10, 20);    cout &lt;&lt; a &lt;&lt; endl;    //本质上是operator&lt;&lt;(cout,a)}int  main(){    test();    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="编译器默认提供的类的函数"><a href="#编译器默认提供的类的函数" class="headerlink" title="编译器默认提供的类的函数"></a>编译器默认提供的类的函数</h4><p>1、默认构造</p><p>2、默认析构</p><p>3、拷贝构造</p><p>4、赋值运算符 operator=，（类可以直接进行赋值运算）</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person{public:    Person(int age)    {        m_age = new int(age);   //将age数据开辟到堆区    }    int* m_age;};void test(){    Person p1(18);    cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_age &lt;&lt; endl;    Person p2(20);    p2 = p1;    //直接进行赋值运算    cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_age &lt;&lt; endl;}int  main(){    test();    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="运算符重载（赋值运算）"><a href="#运算符重载（赋值运算）" class="headerlink" title="运算符重载（赋值运算）"></a>运算符重载（赋值运算）</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person{public:    Person(int age)    {        m_age = new int(age);   //将age数据开辟到堆区    }    Person&amp; operator=(Person&amp; a)    {        if (m_age != NULL)        {            delete m_age;            m_age = NULL;        }        this-&gt;m_age = new int(*a.m_age);    //深拷贝，解决堆区重复释放的问题，返回Person的引用是为了连续赋值        return *this;    }    int* m_age;};void test(){    Person p1(18);    cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_age &lt;&lt; endl;    Person p2(20);    Person p3(30);    p3 =p2 = p1;    //直接进行赋值运算    cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_age &lt;&lt; endl;    cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_age &lt;&lt; endl;}int  main(){    test();    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>class 子类 : 继承方式 父类</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class basepage{public:    void header()    {        cout &lt;&lt; &quot;aaaaaa&quot; &lt;&lt; endl;    }    void footer()    {        cout &lt;&lt; &quot;bbbbbb&quot; &lt;&lt; endl;    }    void left()    {        cout &lt;&lt; &quot;ccccccc&quot; &lt;&lt; endl;    }    void right()    {        cout &lt;&lt; &quot;dddddddd&quot; &lt;&lt; endl;    }};class java:public basepage{public:    void content()    {        cout &lt;&lt; &quot;this is java&quot; &lt;&lt; endl;    }};void test(){    java ja;    ja.header();    ja.footer();    ja.left();    ja.right();    ja.content();}int  main(){    test();    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><p>父类中的private，子类不可访问</p><p>1、公共继承</p><p>class 子类 : public 父类</p><p>public——public</p><p>protected—— protected</p><p>2、保护继承</p><p>class 子类 : protected 父类</p><p>public、protected——protected</p><p>3、私有继承</p><p>class 子类 : private 父类</p><p>public、protected——private</p><h4 id="利用开发人员命令提示工具查看对象模型"><a href="#利用开发人员命令提示工具查看对象模型" class="headerlink" title="利用开发人员命令提示工具查看对象模型"></a>利用开发人员命令提示工具查看对象模型</h4><pre><code>C:\Users\xx\source\repos\Project1\Project1&gt;cl /d1 reportSingleClassLayoutbasepage 源.cpp//C:\Users\xx\source\repos\Project1\Project1&gt;为cpp文件所在路径 basepage为类名</code></pre><h4 id="子类中同名属性的访问"><a href="#子类中同名属性的访问" class="headerlink" title="子类中同名属性的访问"></a>子类中同名属性的访问</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class base{public:    base()    {        m_a = 100;    }    int m_a;};class son :public base{public:    son()    {        m_a = 200;    }    int m_a ;};void test(){    son s;    cout &lt;&lt; s.m_a &lt;&lt; endl;     //直接访问为子类的属性    cout &lt;&lt; s.base::m_a &lt;&lt; endl;   //父类中同名属性访问需要加上作用域}int  main(){    test();    system(&quot;pause&quot;);    return 0;}#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class base{public:    base()    {        m_a = 100;    }    void aaaa()    {        m_a = 200;    }    void aaaa(int b)    {        m_a = 500;    }    int m_a;};class son :public base{public:    son()    {        m_a = 300;    }    void aaaa()    {        m_a = 400;    }    int m_a ;};void test(){    son s;    s.aaaa();    cout &lt;&lt; s.m_a &lt;&lt; endl;    //400    s.base::aaaa();    cout &lt;&lt; s.base::m_a &lt;&lt; endl;    //200    s.base::aaaa(10);          //只要出现同名，父类中的函数都会被隐藏必须加作用域才能访问    cout &lt;&lt; s.base::m_a &lt;&lt; endl;    //500}int  main(){    test();    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>class 子类 ：public 父类1，public 父类2……</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class base1{public:    base1()    {        m_a = 100;    }    int m_a;};class base2{public:    base2()    {        m_b = 200;    }    int m_b;};class son :public base1,public base2     //多继承{public:    son()    {        m_c = 300;    }     int m_c ;};void test(){    son s;    cout &lt;&lt; s.m_a &lt;&lt; endl;    cout &lt;&lt; s.m_b &lt;&lt; endl;    cout &lt;&lt; s.m_c &lt;&lt; endl;}int  main(){    test();    system(&quot;pause&quot;);    return 0;}</code></pre><h4 id="父类的引用指向子类的对象"><a href="#父类的引用指向子类的对象" class="headerlink" title="父类的引用指向子类的对象"></a>父类的引用指向子类的对象</h4><pre><code>class Animal{public:    void speak()    {        cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;    }};class cat:public Animal{public:    void speak()    {        cout &lt;&lt; &quot;猫在说话&quot; &lt;&lt; endl;    }};void dospeak(Animal &amp;animal)      {    animal.speak();      //编译的时候提前分配空间，输出一定是“动物在说话”}void test(){    cat a;    dospeak(a);      //允许父类的引用指向子类的对象 Animal &amp;animal = cat，不需要做类型转换}</code></pre><h4 id="动态多态（父类函数前加virtual）"><a href="#动态多态（父类函数前加virtual）" class="headerlink" title="动态多态（父类函数前加virtual）"></a>动态多态（父类函数前加virtual）</h4><p>满足条件<br>1、有类的继承关系<br>2、子类重写父类的虚函数（函数返回类型、函数名、参数条件都相同）<br>3、全局函数中父类通过指针或引用指向子类对象</p><pre><code>class Calculator{public:    virtual int get_result()=0;       //纯虚函数    //有纯虚函数的类称为抽象类    //1、不能实例化对象；2、子类需重写纯虚函数，否则仍为抽象类    int a;    int b;};       //抽象的计算器类class ADDCalculator : public Calculator{public:    int get_result()    {        int c = this-&gt;a + this-&gt;b;        return c;    }};class MULCalculator : public Calculator{public:    int get_result()    {        int c = this-&gt;a * this-&gt;b;        return c;    }};class SUBCalculator : public Calculator{public:    int get_result()    {        int c = this-&gt;a - this-&gt;b;        return c;    }};void test(){    //多态的两种实现方式    //1、父类的指针指向子类的对象    Calculator* abc = new SUBCalculator;       abc-&gt;a = 10;    abc-&gt;b = 20;    int c = abc-&gt;get_result();    cout &lt;&lt; c &lt;&lt; endl;    delete abc;    //2、父类的引用指向子类的对象    SUBCalculator A;    Calculator&amp; cal = A;    cal.a = 10;    cal.b = 10;    int d = cal.get_result();    cout &lt;&lt; d &lt;&lt; endl;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>四月裂帛   简媜</title>
      <link href="2020/11/11/%E5%9B%9B%E6%9C%88%E8%A3%82%E5%B8%9B%20%20%20%E7%AE%80%E5%AA%9C/"/>
      <url>2020/11/11/%E5%9B%9B%E6%9C%88%E8%A3%82%E5%B8%9B%20%20%20%E7%AE%80%E5%AA%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="四月裂帛"><a href="#四月裂帛" class="headerlink" title="四月裂帛"></a>四月裂帛</h1><p>摘自台湾作家简媜《女儿红》的开篇散文《四月裂帛》<br><em>“我们是诗的后裔！”，我们也应该诗意地栖息</em></p><p>​        三月的天书都印错，竟无人知晓。<br>　　近郊山头染了雪迹，山腰的杜鹃与瘦樱仍然一派天真地等春。三月本来无庸置疑，只有我关心瑞雪与花季的争辩，就像关心生活的水潦能否允许生命的焚烧。但，人活得疲了，转烛于锱铢、或酒色、或一条百年老河养不养得起一只螃蟹？于是，我也放胆地让自己疲着，圆滑地在言语厮杀的会议之后，用寒鸦的音色赞美：“这世界多么有希望啊！”然后，走。<br>　　直到一本陌生的诗集飘至眼前，印了一年仍然初版的冷诗，（我们是诗的后裔！）诗的序写于两年以前，若洄溯行文走句，该有四年，若还原诗意至初孕的人生，或则六年、八年。于是，我做了生平第一件快事，将三家书店摆饰的集子买尽——原谅我卤莽啊！陌生的诗人，所有不被珍爱的人生都应该高傲地绝版！<br>　　然而，当我把所有的集子同时翻到最后一页题曰最后一首情诗时，午后的雨丝正巧从帘缝蹑足而来。三月的驼云倾倒的是二月的水谷，正如薄薄的诗舟盛载着积年的乱麻。于是，我轻轻地笑起来，文学，真是永不疲倦的流刑地啊！那些黥面的人，不必起解便自行前来招供、画押，因为，唯有此地允许罪愆者徐徐地申诉而后自行判刑，唯有此地，宁愿放纵不愿错杀。<br>　　原谅我把冷寂的清官朝服剪成合身的寻日布衣，把你的一品丝绣裁成放心事的暗袋，你娴熟的三行连韵与商簌体，到我手上变为缝缝补补的百衲图。安静些，三月的鬼雨，我要翻箱倒箧，再裂一条无汗则拭泪的巾帕。<br>　　我不断漂泊<br>　　因为我害怕一颗被囚禁的心<br>　　终于，我来到这一带长年积雨的森林<br>　　你把七年来我写给你的信还我，再也没有比这更轻易的事了。<br>　　约在医院门口见面，并且好好地晚餐。你的衣角仍飘荡着辛涩的药味，这应是最无菌的一次约会。可惜的，惨淡夜色让你看起来苍白，仿佛生与死的演绎仍鞭笞着你瘦而长的身躯。最高的纪录是，一个星期见十三名儿童死去，你常说你已学会在面对病人死亡之时，让脑子一片空白，继续做一个饱餐、更浴、睡眠的无所谓的人。在早期，你所写的那首《白鹭鸶》诗里，曾雄壮地要求天地给你这一袭白衣；白衣红里，你在数年之后《关渡手稿》这样写：<br>　　恐怕<br>　　我是你的尸体衣裳<br>　　非婚礼华服<br>　　并且悄悄地后记着：“每次当病人危急时，我们明知无用，仍勉强做些急救的工作。其目的并非要救病人，而是来安慰家属。”<br>　　你早已不写诗了，断腕只是为了编织更多美丽的谎言喂哺垂死病人绝望的眼神。也好让自己无时无刻沉浸于谎言的绚丽之中，悄然忘记四面楚歌的现实。你更瘦些，更高些，给我的信愈来愈短，我何尝看不出在急诊室、癌症病房的行程背后，你颤抖而不肯落墨讨论的，关于生命这一条理则。<br>　　终于，我们也来到了这一刻，相见不是为了圆谎为了还清面目，七年了，我们各自以不同的手法编织自己的谎，的确也毫发未损地避过现实的险滩。唯独此刻，你愿意在我面前诚实，正如我唯一不愿对你假面。那么，我们何其不幸，不能被无所谓的美梦收留，又何等幸运，历劫之后，单刀赴会。<br>　　穿过新公园，魅魅魑魑都在黑森林里游荡，一定有人殷勤寻找“仲夏夜之梦”，有人临池摹仿无弦钓。我们安静地各走自的，好像相约要去探两个挚友的病，一个是七年前的你，一个是七年前的我，好像他们正在加护病房苟延残喘，死而不肯眼目，等亲人去认尸。<br>　　“为什么走那么快？”你喊着。<br>　　“冷啊！而且快下雨了。”<br>　　灯光飘浮着，钢琴曲听来像粗心的人踢倒一桶玻璃珠。餐前酒被洁净的白手侍者端来，耶稣的最后晚餐是从哪儿开始吃的？<br>　　“拿来吧，你要送我的东西。”<br>　　你腼腆着，以迟疑的手势将一包厚重的东西交给我。<br>　　“可以现在拆吗？”我狡诈地问。<br>　　“不行，你回去再看，现在不行。”<br>　　“是什么？书吗？是圣经？……还是……真重哩！”我掂了又掂，七年的重量。<br>　　“你……回去看，唯一、唯一的要求。”<br>　　于是，我装作什么都不知道，继续与你晚餐，我痛恨自己的灵敏，正如厌烦自己总能在针毡之上微笑应对。而我又不忍心拂袖，多么珍贵这一席晚宴。再给你留最后一次余地，你放心，凄风苦雨让我挡着，你慢慢说。<br>　　“后来，我遇到第二个女孩子，她懂得我写的、想的，从来没有人像她那样……”你说。<br>　　“我察觉在不知道的地方，有一种东西，好像遥远不可及，又像近在身边；似在身外，又似在身内，一直在吸引我。我无法形容那是什么——或许是使得风景美丽的不可知之力量；或许是从小至今，推动我不断向前追求的不能拒绝之力量；或许是每时刻我心中最深处的一种呼唤、一种喜悦、一种梦；或许是考娄芮基（coleridge）在他的《文学传记》所述的‘自然之本质’，这本质，事先便肯定了较高意义的自然与人的灵魂之间，存在着一种‘关联’……想着，想着，《关渡手稿》就在这种心境写下来。……”年轻的习医者在信上写着。<br>　　“她懂你像你懂自己一样深刻吗？”我问。<br>　　“我试着让她知道，我为什么而活。”你说。<br>　　“来此两个多星期，天天看病人，跟在医院无两样。空间多，看海与观星成了忘我的消遣。我很高兴能走入‘时间’里面去体会时间的分秒之悸动，圣经写说，人生若经过炼金之人的火及漂布之人的碱，必能尝到丰溢的酒杯，于是我更能体会濒死病人的呻吟，可以真实地走过病眼深水的波浪洪涛。<br>　　在你的瀑布发声，深渊就与深渊响应’之际，虽然长夜仍然漫漫，我仍旧守候在病人的身旁，守候着风雨之中的花蕾，守候着天发亮的晨星……这是我衷心想告诉你的……”在东引海边的军营里，有一封信这么写。<br>　　“为了她我拒绝所有的交往，我告诉另一个女孩子，我在等人；她哭了，也嫁人了。”你颓唐起来。<br>　　“啊！”我说：“这个女孩子真是铜墙铁壁啊！是你不能接受她是个非基 . 督徒，还是她不能接受你的主？”<br>　　“我曾由只要去爱不是去同情的初学者，变成现在差不多以make money为主的医匠。我甚至陷在希望借研究与学术发表演讲来满足内心好大喜功之欲望里而不可自拔，我甚至怕自己突因某种原因而死亡（很多医师因工作太累，开车打瞌睡而撞死）。目前，我正在钻研一种‘内生性类似毛地黄之因子’，我渴求能在两年内把它分析出来公诸于世，以满足一己暂时的快感……我不知道我是谁？<br>　　“我渴望婚姻，但也害怕婚姻带来的角色改变，我是痛苦的空城。直到，我碰到了一位‘女作家’，我非常喜欢和她做朋友，但我的直觉和教会及所有的人认为我不能和一个非基 . 督徒结婚。我相信我有能力做她的好朋友，但我不知道能否做她的好丈夫？我不能接受夫妻因信仰所发生的任何冲突，我又很希望这位女作家过着幸福快乐的日子，我当然希望结婚的对象也是基 . 督徒……我可能选择独身，我是矛盾的人。”第四十二封信写着。<br>　　“的确，”我啜饮着烫舌的咖啡：“天上的父必然要选择他地上的媳，如同平凡的妇人也想选择她天上的父。”<br>　　“我不懂她心中真正的想法，她真是铜墙铁壁！”你说。<br>　　“她或许了解你的坚持，你却不一定进得去她固执的内野。你们都航行于真理的海，沿着不同的鲸路。你只希望她到你的船上，你知道她的舟是怎么空手造成的？她爱她的扁舟甚于爱你，犹如你爱你的船甚于爱她。如果你为她而舍船，在她的眼中你不再尊贵，如果她为你而弃舟，她将以一生的悔恨磨折自己。的确，隐隐有一种存在远远超过爱情所能掩盖的现实，如果不是基于对永恒生命衷心寻觅而结缡的爱，它不比一介微尘骄傲。你们曾经欢心惊叹，发现彼此航行于同一座海洋；现在，却相互争辩，只为了不在同一条船上。假设，她愿意将你的缆绳结在她的舟身，不要求你弃船，那么你能否接受她的绳，不要求她覆舟？如果比身并航也不为你的宗教所允许，你只有失去她，永远的失去她。”<br>　　“我是一个失败的证道者！”你喟然着。<br>　　“不！”我说：“如果你不曾成功地摊开你的内心，她早就成为你痛苦的妻。当你朗诵诗篇二十三给她：‘耶和华是我的牧者，我必不致缺乏。他使我躺卧在青草地上，领我在可安歇的水边。他使我的灵魂苏醒，为自己的名引导我走义路。’你要相信，她才答应自己去寻找另一处无人到过的迦南美地。<br>　　如果她在你心中仍然美丽，就是因为这一身永不妥协的探索与敢于迎战的清白足以美丽。她一生不曾侍奉任何的主，而她赞美你，等同赞美了上帝。你信仰了主，你当终生仰望，你既然住着耶和华的殿，享有他赐予的粮，你何苦再寻一座婚姻的空壳？我只听说有人千方百计将他的茅屋改成宫殿，未曾闻过在宫殿里另筑茅屋。你成全了她走自己的义路，这是你赐她最大的福音。她住在她那寒伧的磨坊，无一日不在负轭、磨粮，你要体会，不是为了她自己，为了不可指认、不能执著的万有——让虚空遍满琉璃珍珠，让十五之后日日是好日，让一介生命甘心以粉身碎骨的万有；如同你活着为了光耀上帝。你要眼睁睁看她怎么粉碎，正如她眼睁睁看你七年。”<br>　　最后一封信这样落笔：“在我心目中，你一直是个尊贵的灵魂，为我所景仰。认识你愈久，愈觉得你是我人生行路中一处清喜的水泽。<br>　　“为了你，我吃过不少苦，这些都不提。我太清楚存在于我们之间的困难，遂不敢有所等待，几次想忘于世，总在山穷水尽处又悄然相见，算来即是一种不舍。<br>　　“我知道，我是无法成为你的伴侣，与你同行。在我们眼所能见耳所能听的这个世界，上帝不会将我的手置于你的手中。这些，我都已经答应过了。<br>　　“这么多年，我很幸运成为你最大的分享者，每一次见面，你从不吝惜把你内心丰溢的生息倾注于我的杯。像约书亚等人从以实各谷砍了葡萄树的一枝，上头有一挂葡萄，又带了些石榴和无花果来……你让我不致变成一个盲从的所知障者，你激励我追求无上自由的意志，如果有一天我终能找到我的迦南之野，我得感谢你给我翅膀。<br>　　“请相信，我尊敬你的选择，你也要心领神会，我的固执不是因为对你任何一桩现实的责难，而是对自己个我生命忠贞不二的守信。你甚美丽，你一向甚我美丽。<br>　　“你也写过诗的，你一定了解创作的磨坊一路孤绝与贫瘠，没有一日，我卑微的灵不在这里工作、学习。若我有任何贪恋安逸，则将被遗弃。走惯贫沙，啃过粗粮，吞咽之时竟也有蜜汁之感，或许，这是我的迦南地。<br>　　“不幻想未来了。你若遇着可喜的妹妹，我当祈福祝祷。<br>　　你真是一个令人欢喜的人，你的杯不应该为我而空。<br>　　“就这样告别好了，信与不信不能共负一轭。”<br>　　且让我们以一夜的苦茗<br>　　诉说半生的沧桑<br>　　我们都是执著而无悔的一群<br>　　以飘零作归宿<br>　　在你年轻而微弱的生命时辰里，我记载这一卷诘屈聱牙的经文，希望有朝一日，你为我讲解。<br>　　如果笔端的回忆能够一丝丝一缕缕再绕个手，我都已经计算好了，当我们学着年轻的比丘尼入舍卫大城乞食，于其城中次第乞已，还至本处时，我要把钵中最大最美的食物供养你，再不准你像以前软硬兼施趁人不备地把一片冰心掷入我的壶。<br>　　我们真的因为寻常饮水而认识。<br>　　那应该是个薄夏的午后，我仍记得短短的袖口沾了些风的纤维。在课与课交接的空口，去文学院天井边的茶水房倒杯麦茶，倚在砖砌的拱门觑风景。一行樱瘦，绿扑扑的，倒使我怀念冬樱冻唇的美，虽然那美带着凄清，而我宁愿选择绝世的凄艳，更甚于平铺直叙的雍容。门墙边，老树浓荫，曳着天风；草色釉青，三三两两的粉蝶梭游。我轻轻叹了气，感觉有一个不知名的世界在我眼前幻生幻化，时而是一段佚诗，时而变成幽幽的浮烟，时而是一声惋惜——来自于一个人一生中最精致的神思……这些交错纷叠的灵羽最后被凌空而来的一声鸟啼啄破，然后，另一个声音这么问：<br>　　“你，就是简媜吗？”<br>　　我紧张起来，你知道的，我常忘记自己的名字，并且抗拒在众人面前承认自己，那一天我一定很无措吧！迟顿了很久才说：“是。”又以极笨拙的对话问：“那，你是什么人？”<br>知道你也学中文的，又写诗，好像在遍野的三瓣酢浆中找四瓣的幸运草：“唷，还有一棵躲在这！”我愉快起来就会吃人：“原来是学弟，快叫学姊！”你面有难色，才吐露从理学院辗转到文学殿堂的行程，倒长我二岁有余。我看你温文又亲和，分明是邻家兄弟，存心欺负你到底：“我是论辈不论岁的！”你露齿而笑，大大地包容了我这目中无人的草莽性情。<br>　　那一午后我归来，莫名地，有一种被生命紧紧拥住的半疼半喜，我想，那道拱门一定藏有一座世界的回忆。<br>　　毕竟，我只善于口头称霸，在往后与你书信嬗递，才发觉你瘦弱的身躯底下，凝炼了多少雄奇悲壮的天质，而你深深懂得韬光养晦，只肯凿一小小的孔，让琢磨过的生命以童子的姿势嬉嬉然到我眼前来。我们不谈身世只论性命，更多时候在校园道上相遇，也只是一语一笑作别，但我坚信：“这人是个大寂寞过的人！”<br>　　那时候，你的面目早已因潜伏的病灶难靖，稍稍地倾斜着，反正已经割过了而且是个慢性子的瘤，就不必管吧，只在你心力用瘁的时候，才憔悴起来，我叫你当心，你复来的信不痛不痒地说：“今早文心课见你挽抱书本飘然而去，霎时间萌生一种远飏的感觉，没来得及跟你说。有回上声韵，下了课，你倦极而伏案，其时感觉也是一惊。记得有次夜深，与你不期然遇，你说从总图出来，回宿舍去。夜色下的你步履决定，却透着层弱倦后的苍白。一直没能多问候你，反而是你看出我的憔悴。”你始终不愿意称我“简媜”，说这二字太坚奇铿锵，带了点刀兵，你宁愿正正经经地写下“敏媜”，说有了这“敏”字，行云流水起来，不遭忌的。我深深动容，你一片片莲灿，都为我惜生，而我能为你做什么？性格里横槊赋诗的草莽气质，总让我对最亲近的人杀伐征讨。难得有一回清清淡淡的小聚，临别时，我不经心窜出那头兽、那忘情负义恩将仇报的猛禽：“保重哟，下一次见面或许九天，或九年。”你清和的面容浮掠一丝秋瑟，宽怀地笑纳这些语锋契机，你报平安的信通常这么作结：“写信、说话，欢喜日复一日。看你什么时候有空，小谈。我担心一语成谶。”<br>　　尔后，我离了学院，日复日载饥载渴，过的是牛饮而后快的星夜。偶有不死的诗心，才写些哀哀怨怨的信给亲近的人，你总是快快地回：“外出三天，深夜踏雨归来，檐前出现一小叠信。中有你亲切的字迹，你的信柬自然令我喜欢。……<br>　　我的病情，好好坏坏，终须挨上一刀才见分晓。近两个月来的抱病自守，旦夕之间，情知对于生命底千般流转，尽须付与无尽的忍爱。我想，他朝小痊，如你之奔驰，亦须这样。一步一履，无非修行。至此，我依然深心乐观，来日或聚，愿其时你的事业大势底定，我亦澡雪精神。”<br>　　我们深心乐观着未来，几次击掌切磋，暗暗以创格自许，不屑袭调。负气使才如我，滔滔洒墨，似欲与千夫万夫一拚。<br>　　你见我清瘦异常，只吩咐我不可太夜太累，我委屈了，说：<br>　　“就活这么一次，我要飞扬跋扈！”你语重心长地说：“早慧，难享天年的，古来如此。”<br>　　你珍贵我这顽桀的生命，大大地甚于你自己的。那一回生日，你特地去寻玉送我，一龙一凤绕着净瓶（啊！会是观音的净瓶吗？），你说鬻玉的老者称这块玉的肌理具荷质，返家的途中经过南海路，你去植物园的荷花池，轻轻地轻轻地将这玉沁了又沁……你说：“生命恒有繁华落尽的感觉，只不过，不染淤泥！”<br>　　病魔却与你弄斧耍戗，你的眼开始不自觉地泪，夜半常因拭泪而难以入眠，你谦称这是宿业使然。在你卜居的深山穷野，你宛若处子与生灭大化促膝而谈，抱病独居的信，不改涓涓细流的字迹：“有天半夜不能安睡，出至阳台。山间天象澄明，月光大片大片洒落一地。忽然间，我看见自己月下的影子，细细瘦瘦，怯怯地，触目竟十分眼熟，但那分明不是日光中的‘我’。我呆呆地忖忖想想，啊，是了——是童话时候的‘我’！我好感动地望着那片身影，然后牵他入梦。偶得一悟，心情愿如庄周，处于病与不病之间。”<br>　　你第二度开刀，除去右颜面突变的肉瘤，我将一串琥珀念珠赠你，那是寺里一名师父突然脱下赠我的，我欢喜生命中“突然”的意象。你认真地戴在手腕，虚弱地在病榻上闭目。我又天真起来了，仿佛一名间谍，在你短兵相接的战场之前，先给你解药，你此后可以大胆地无惧地去迎喂毒的流箭。病后，你说：“我渐渐愿意把所有的悲沉、蒙昧、大痛、无明都化约到一种素朴的乐观上，我认为它是生命某种终极的境界。你知我知。”<br>　　最珍贵而美丽的，应该是你赴港念比较文学之前的半年。<br>　　你诗写得少了，专志狼吞文学批评的典籍，你戏谑这是一桩“反美”的工程，但要我千万注意，你并非不爱美。我说：<br>　　“管你家的什么美不美，天天念原文书，把一个人念得豆芽菜似的，这种美简直王八蛋！”你每星期总要回长庚医院追踪病情，我们相约在中午，趁我歇班的时刻，你教我念书。常常在市嚣流矢的小咖啡店里，你取出一叠白纸、一支钢笔，在喝了一口微冷的红茶之后，开始以沙哑沉浊的声音，为我唤来“福寇”（michel foucault），我静静地抱膝听着，进入神思所能触摸的最壮阔与最阴柔的空间，你的话幽浮起来：<br>　　“……如今，书写已和献祭发生关联，甚至和生命的献祭发生关联……”我幡然有悟：“等等，我下一本书的架构出来了，你要不要听！”知识的考掘通常转化为创作的考掘，我是锈刀，拿你当磨刀石。你不也说了吗，我的生命太千军万马，终究不会听你这座“紫微”。实而言之，你是一则遥远的和平，为了你，我必须不断地战争。<br>　　有一回，茶冷言尽，你取出一张泛黄的黑白照片让我瞧：<br>　　一名十岁男童倚在漫画书店的租台边，白白净净的怯生生的，眼睛里有一股神秘的招引与微燃的悲喜，静静地与世界相看。<br>　　我惊叹起来：“多美啊！是你吗？”你欢喜地说：“是！”<br>　　那一回，你送我回报社上班，沿着木棉击掌、械实落墨的砖道，你微微地喟叹：“天！给我时间！”<br>　　香港一年，你终因病发大量出血而辍学，从中正机场直奔林口长庚，医师已开了病危通知书。你却幽幽转醒，看着病床边来来往往的友好、同窗，或者，你还在等，当养育的父母双亡，亲生的父母待寻。你那时已不能进食，肉瘤塞住口舌，话也不能说了。你见我来，兀自挣身下床，从杂乱的行李中掏出一块精致的香皂，多少年前，我说过一日三浴更甚于心头欢喜，你在纸上写着：“多洗澡！”那一刹——那百千万亿年只可能有一回的一刹，我想狠狠地置你于死。<br>　　半年来，我抗拒着再去看你，想回向给你七七四十九遍的经诵终于不能尽读，我压抑每一丝丝一缕缕一角角关于你的挂念。只有两回梦见，一次你以赤子的形象从半空掠过，我仰首不复寻踪；一次你款款而来，白白净净的面目，我大喜，问：“你好了？”你笑而不答，许久许久才说：“还没开始生病啦！”梦醒后，深深地痛恨自己，现世里的大欢大美被解构得还不够吗？连在可以作主的梦土，也要懦怯地缴械。我终究是个懦夫，不配英雄谈吐。<br>　　那么，敬爱的兄弟，我们一起来回忆那一日午后，所有已死的神鬼都应该安静敷座，听我娓娓诉说。<br>　　那一日，我借了轮椅，推你到医院大楼外的湖边，秋阳绵绵密密地散装，轮转空空，偶尔绞尽砖岸的莽草。我感觉到你的瘦骨宛若长河落日，我的浮思如大漠孤烟。当我们面湖静坐，即将忘却此生安在，突然，遥远的湖岸跃出一行白鹭，抟扶摇直上掠湖而去，不复可寻。湖水仍在，如沉船后，静静的海面，没有什么风，天边有云朵堆聚着。<br>　　你在纸上问我：“几只？”<br>　　我答：“十二只。”你平安地颔首。<br>　　也许，不再有什么诘屈聱牙的经卷难得了你我。当你恒常以诗的悲哀征服生命的悲哀，我试图以小说的悬崖瓦解宿命的悬崖；当我无法安慰你，或你不再关怀我，请千万记住，在我们菲薄的流年，曾有十二只白鹭鸶飞过秋天的湖泊。<br>　　犹似存在主义，<br>　　或是老庄，<br>　　或是一杯下午茶，<br>　　或两本借来的书。<br>　　百般凌虐你，你都不生气，或，只生一小会儿气。好似在你那里存了一笔巨款，我尽情挥霍，总也不光。有时失了分寸，你肃起一张沧桑后的脸，像一个蹇途者思索不可测的驿站，我就知道该道歉了，摸摸你深锁的额头说：“什法子，谁叫你欠我。不生气，生气还得付我利息。”<br>　　常常在早餐约会，或入了夜的市集。热咖啡、双面煎荷包蛋、烘酥了土司，及三分早报。你总替我放糖、一圈白奶，还打了个不切实际的哈欠。我喜欢晨光、翻报、热咖啡的烟更甚于盘中物，你半哄半骗，说瘦了就丑，我说：“喂，就吃！”<br>　　你果真叉起蛋片进贡而来，我从不吝惜给予最直接的礼赞：<br>　　“今天表现不错，记小功一支。”<br>　　早晨恒常令我欢心，仿佛摄取日出的力量，从睡眼沉静射入惊蛰的流动，有了奔驰的野性及征服的欲望。早晨对你却是苛责的，你雾着一张脸，听我意兴风发地擘画每一桩工作，帮你整理当日的行程及争辩的重点，战役的成果未必留给我们，但我们联手打过漂亮的仗。<br>　　入夜的城市更显得蠢蠢欲动，入夜的我通常是一只安静的软体动物，容易认错、善于仆役，不扎别人的自尊。你活跃于墨色的时空，以锐利的精神带着我游走于市集。一碗卤肉饭、石斑鱼汤、水煮虾也是令人难忘的饮食起居。我擅于剥虾、剔无刺的鱼肉，伺候你。你尽管放心地细数我的不对，定谳白日的蛮悍，我一向从善如流，乖乖地向你忏悔。<br>　　当市集悄悄撤退，夜也恹了，我打起一枚长长的呵欠，你说：“走吧！回家。”你走你的路，我走我的归途。这城市无疑是我们巨构的室家，要各自走过冗长的通道，你回你的卧室，我有我的睡榻。<br>　　那么，的确必须用更宽容的律法才能丈量你我的轨道。你不曾因为我而放弃熟悉的生命潮汐——不管是过往的情涛、现实的波澜，或即将逼近的浪潮；我也不必为你而修改既定的秩序——我有我不能割舍的人际、工作的程序，及关于未来的编排。当我们相约，其实是趁机将自己从曲曲折折的轨道释放出来，以大而无当的姿势携手、寻路。你四十过二的音色里仍留有不肯成熟的童话（要不，你怎么老是叉橡皮筋偷袭我！）；我二十又七的华容仍忘怀不去初为儿女的恣意（挺喜欢捧你的大手，一支一支地啃你的指头！）；你时而化童时而老迈，我时而为人时而原兽，我们生动地演出内心被禁锢的角色，以城市为舞台，行人当盲目的观众。那些令人疲惫的典章制度不容质疑总可以暂忘，你虽然抱怨半生颠踬无以转圈，我却不曾怂恿你或然言弃——那些包袱早已变成心头肉，在我们分手后仍然继续由你背负的。如是，我期望每一次相聚，透过理智的剖析与情感之疏浚，更助益你昂然驼行。<br>  我深知，情会淡爱会薄，但作为一个坦荡的人，通过情枷爱锁的鞭笞之后，所成全的道义，将是生命里最昂贵的碧血。因而，你可以原始地袒露，常常促膝一夜，谈你孑然成长的大江南北、谈梦幻与现实互灭、谈你云烟过眼的诸多女人、谈你远去的妻与儿女……常常，我看到那一颗三十多年未落的噙泪。<br>　　同等地，我得以在你身上复习久违的伦常，属于父执与兄长的渴望。过于阴柔的家境，促使我必须不断训练自己雄壮、摹仿男系社会的权威；而我生命的基调，却是要命的抒情传统，三秋桂子十里芰荷的那种，遂拿你砌湖，我得以歌尽舞影，临水照镜（啊！我终究必须恋父情结）。实则如此，每一桩生命的垦拓，须要吮取各式情爱的果实，凡是亏空的滋味，人恒以内在的潜力去做异次元的再造。你在不知不觉中已被我修改，按着我心中的形象发音；正如我愿意为你而俯身，将自己捏成宽口的罍，以盛住你酒后崩塌的块垒——<br>　　任何一桩情缘，如果不能激励出另一种角色与规则，以弥补梦土与现实之间的断崖，终究不易被我珍爱。<br>　　于是，我们很理智地辩论着婚姻。<br>　　你说，不曾歇息的情涛，总难免落得一身萧索，过往的女人不是不爱，却发现愈爱得深愈陷泥淖；我说，这是剥夺，爱情之中藏有看不见的手。你说，如果我们结婚如何？我问，你视我为何？难道纷落的情锁不曾令你却步？你说，我在你心中不等同于女人，属于一种透明的中性——像白昼与黑夜，时而如男人清楚，时而如女性张皇，你能充分享受诉说，从最崔嵬的男峰吐露至最婉柔的女泽（你有时细心得像一名婢女），我欢愉你所陈述的，那表示，一个人对他（她）内在生命做多元创造的无限可能。而我开始叙述，关于多年来我们另辟蹊径，如今俨然一条轨道的情爱（请注意，放弃世俗轨道的通常要花更多心血为自己领航，且不再有回头的可能）。<br>​    我们成就一种无名的名分，住在无法建筑的居室，我不要求你成为我的眷属如同我厌烦成为任何人的局部，你不必放弃什么即能获得我的灌注，我亦有难言的顽固却能被你呵护，我们积极相聚也品尝不得不的舍离，遂把所能拥有的辰光化成分分秒秒的惊叹。如果爱情是最美的学习，我愿意作证，那是因为我们学到了布施胜于占取，自由胜于收藏，超越胜于厮守，生命道义胜于世俗的华居。想必你了解，婚姻只是情爱之海的一叶方舟，如果我们愿意乘桴浮于海，何必贪恋短暂的晴朗——要纵浪就纵浪到底吧！我已拍案下注，你敢不敢坐庄？<br>　　我们还要一座壳吗？让壳内众所皆知的游戏规则逐渐吞噬我们的章法。以我不靖的个性，难以避免对你层层剥夺；以你根深柢固的男系角色，终究会逐步对我干涉。原宥我深沉的悲观，婚姻也有雄壮的大义，但不适合于我——我喜于实验，易于〖屏蔽***〗，遂有不断地、不断地裂帛。<br>　　我情愿把这城市当成无人的旷野，那一夜，我爬上大厦广场的花台，你一把攫住，将我驼在肩上，哼着歌儿，凛凛然走过两条街；被击溃之后如果有内伤，那内伤也带着目中无人的酣畅。有一日，深夜作别，我内心击打着滔滔逝水的悲切，不忍责忍你什么，只想一个人把漫漫长夜走完，你说起风了，脱下外衣披我，押我上车，在站牌旁频频向我挥手，然后孤独地走向你候车的街口。那一刹，我又剑拔弩张，想狠狠刺大化的心脏，遂在下一站下车，拚命地跑，越过城市将灭的灯色，汗水淋漓地回到你的背后，你多么单薄，掏烟、点火，长长地向夜空喷雾，像一名手无寸铁的人！我倏地蒙住你的眼睛，重重地咬你的耳朵：“不许动！”你回头，看我，错愕的神情转化成放纵的狂笑，我胜利了我说。<br>　　在借来的时空，我们散坐于城市中最凌乱的蓬壁，抽莫名其妙的烟，喝冷言热语的酒，我将烟灰弹入你的鞋里，问：<br>　　“欸，你也不说清楚，嫁给你有什么好处？”<br>　　你脱鞋，将灰烬敲出，说：“一日三顿饭吃，两件花衣裳嘛，一把零用钱让你使。”<br>　　我又把烟灰弹进去：“那我吃饱了做什么？”<br>　　你捏着我的颈子：“这样么，你写书我读——再弹一次看看！”<br>　　我又把烟灰弹进去。<br>　　我随手抽了把单刀<br>　　走了趟雪花掩月<br>　　无声的月夜<br>　　只有鸽子簌簌地飞起<br>　　你怎么来了？<br>　　明明将你锁在梦土上，经书日月、粉黛春秋，还允许你闲来写诗，你却飞越关岭，趁着行岁未晚，到我面前说：“半生飘泊，每一次都雨打归舟。”<br>　　我只能说：“也好，坐坐！”<br>　　关于你生命中的山盟与水逝，我都听说。在茶余饭后，你的身世竟令我思谋，什么样的人，才能与秋水换色，什么样的情，才能百炼钢化成绕指柔。我似乎看到年幼时的你，已然为自己想象海市蜃楼，你愿意成为执戟侍卫，为亘古仅存的一枚日，奉献你绚霞一般的初心。<br>　　那么，请不要再怪罪生命之中总有不断的流星，就算大化借你朱砂御笔，你终究不会辜负悲沉的宿命，击倒的人宁愿刎颈，不屑偷生。这次见你，虽然你的眉目仍未能廓然朗清，倒也在一苇航之后，款款立命。你要日复日吐餔，不吐餔焉能归心。<br>　　把我当成你回不去的原乡，把我的挂念悬成九月九的茱萸，还有今年春末大风大雨，这些都是你的，总有一日，我会打理包袱前去寻你。但你要答应，先将梦泽填为壑，再伐桂为柱，滚石奠基，并且不许回头望我，这样，我才能听到来世的第一声鸡啼。<br>　　你走的时候，留下一把钥匙，说万一你月迷津渡，我可以去开你书中的小屋。我把指环赠你，尽管流离散落，恒有一轮守护你的红日，等候于深夜的山头。<br>　　你说：“还要去庙里烧香，像凡夫凡妇。”<br>　　那日，我独自去碧山岩，为你拈香，却什么话都没说。<br>　　这就是了，所有季节的流转永不能终止。三世一心的兴观群怨正在排练，我却有点冷，也许应该去寻松针，有朝一日，或许要为自己修改征服。<br>　　四月的天空如果不肯裂帛，五月的袷衣如何起头？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Terminator常用快捷键</title>
      <link href="2020/11/11/Terminator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2020/11/11/Terminator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Terminator常用快捷键"><a href="#Terminator常用快捷键" class="headerlink" title="Terminator常用快捷键"></a>Terminator常用快捷键</h1><table><thead><tr><th>命令</th><th>动作</th></tr></thead><tbody><tr><td>Ctrl+Shift+O</td><td>水平分割窗口</td></tr><tr><td>Ctrl+Shift+E</td><td>垂直分割窗口</td></tr><tr><td>F11</td><td>全屏/退出全屏</td></tr><tr><td>Ctrl+Shift+C</td><td>复制</td></tr><tr><td>Ctrl+Shift+V</td><td>粘贴</td></tr><tr><td>Ctrl+Tab</td><td>在分割的各窗口之间切换</td></tr><tr><td>Ctrl+Shift+W</td><td>关闭当前终端</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROS学习</title>
      <link href="2020/11/10/ROS%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/11/10/ROS%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS学习"><a href="#ROS学习" class="headerlink" title="ROS学习"></a>ROS学习</h1><pre><code>rosnode list #列出活跃的节点信息</code></pre><p>​.msg文件就是一个描述ROS中所使用消息类型的简单文本，它放在package的msg目录下，该文件实际上就是每行声明一个数据类型和变量名<br>​ROS客户端库允许使用<strong>不同编程语言</strong>编写的<strong>节点</strong>之间互相通信（即节点的生成形式不受到限制）</p><pre><code>rospy      #python 客户端库roscpp     #c++ 客户端库</code></pre><h4 id="rosrun和roslaunch"><a href="#rosrun和roslaunch" class="headerlink" title="rosrun和roslaunch"></a>rosrun和roslaunch</h4><p>​rosrun允许你使用包名直接运行<strong>一个</strong>包内的节点(不需要知道这个包具体的路径），但是该ros包需要在终端中能找到（即需要source路径），且一个.py或者.cpp文件（可执行文件）就是一个节点。</p><pre><code>rosrun [package_name] [node_name]</code></pre><p>roslaunch可以用来启动定义在launch文件中的<strong>多个</strong>节点</p><pre><code>roslaunch [package] [filename.launch]</code></pre><p>rolaunch中启动的不一定要是单个节点，也可以是另一个子launch文件，例如：</p><p><em>启动单个节点（可执行程序）</em></p><pre><code>&lt;node pkg=&quot;franka_control_node&quot; type=&quot;control_node.py&quot; name=&quot;franka_driver&quot; output=&quot;screen&quot;/&gt;</code></pre><p><em>启动另一个launch文件，即启动其中的所有节点</em></p><pre><code>&lt;include file=&quot;$(find kinect2_bridge)/launch/kinect2_bridge.launch&quot; /&gt;</code></pre><p><strong>机器人gazebo仿真控制     Matlab Simulink工具箱</strong>     <strong>基于模型设计MBD</strong></p><p><strong>基于Matlab/simulink-ros 联合机器人开发</strong></p><pre><code>rosdep install --from-paths src --ignore-src -r -y#可以将该工作空间内的所有package的依赖项一起安装</code></pre><p><strong>roslaunch时遇到无法定位节点</strong></p><pre><code>ERROR: cannot launch node of type [main_control/position_transform.py]: can&apos;t locate node [position_transform.py] in package [main_control]#1、查看是否source路径 2、赋予文件执行权限 sudo chmod +x aaaaaa.py</code></pre><h4 id="包的编译和安装"><a href="#包的编译和安装" class="headerlink" title="包的编译和安装"></a>包的编译和安装</h4><pre><code>mkdir buildcd buildcmake ..makesudo make install#可以将包安装到/home/xx/.local</code></pre><h4 id="启动rqt和rqt-plot报错"><a href="#启动rqt和rqt-plot报错" class="headerlink" title="启动rqt和rqt_plot报错"></a>启动rqt和rqt_plot报错</h4><p>由于matplotlib版本原因启动rqt_plot报错，降级（升级）后仍无效，可考虑卸载qt5再重装<br>    sudo apt remove ros-kinetic-qt5*</p><h4 id="用python写tf的broadcaster"><a href="#用python写tf的broadcaster" class="headerlink" title="用python写tf的broadcaster"></a>用python写tf的broadcaster</h4><pre><code>import tf as tf_ros#在回调函数中写b1 = tf_ros.TransformBroadcaster()b1.sendTransform( (b_point0[0],b_point0[1],b_point0[2] ),    tf_ros.transformations.quaternion_from_matrix(T_base_temp),                rospy.Time.now(),            &apos;/temp&apos;,            &quot;/panda_link0&quot;)#sendTransform参数为（子坐标系原点在父坐标系的位置，姿态（dx,dy,dz,dw）,时刻，子坐标系名称，父坐标系名称）</code></pre><h4 id="用python写tf的listener"><a href="#用python写tf的listener" class="headerlink" title="用python写tf的listener"></a>用python写tf的listener</h4><pre><code>import tf as tf_roslistener = tf_ros.TransformListener()(trans,rot) = listener.lookupTransform(&apos;/base_link&apos;, &apos;/grasp_frame&apos;, rospy.Time(0))#trans为子坐标系原点在父坐标系下的位置，rot为姿态（dx,dy,dz,dw），&apos;/base_link&apos;是父坐标系，&apos;/grasp_frame&apos;是子坐标系，rospy.Time(0)为当前时刻</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora常用快捷键</title>
      <link href="2020/11/10/Typora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2020/11/10/Typora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora常用快捷键"><a href="#Typora常用快捷键" class="headerlink" title="Typora常用快捷键"></a>Typora常用快捷键</h1><h4 id="编辑功能"><a href="#编辑功能" class="headerlink" title="编辑功能"></a>编辑功能</h4><p>新建                                                                  Ctrl + N</p><p>复制为Markdown                                           Ctrl + Shift + C</p><p>粘贴为纯文本                                                   Ctrl + Shift + V</p><p>删除行（在表中）                                           Ctrl + Shift +退格键</p><p>查找                                                                  Ctrl + F</p><p>查找下一个                                                       F3 / Enter</p><p>查找上一个                                                       Shift + F3 / Shift + Enter</p><p>替换                                                                   Ctrl + H</p><h4 id="段落功能"><a href="#段落功能" class="headerlink" title="段落功能"></a>段落功能</h4><p>标题1-6                                                              Ctrl + 1/2/3/4/5/6</p><p>插入表格                                                            Ctrl + T</p><p>插入数学公式                                                    Ctrl + Shift + M</p><p>插入代码块                                                        Ctrl+Shift+K</p><h4 id="格式功能"><a href="#格式功能" class="headerlink" title="格式功能"></a>格式功能</h4><p>加粗                                                                    Ctrl + B</p><p>下划线                                                                Ctrl + U</p><p>斜体                                                                    Ctrl+I</p><p>代码                                                                    Ctrl+Shift+`</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xx</title>
      <link href="2019/11/02/xx/"/>
      <url>2019/11/02/xx/</url>
      
        <content type="html"><![CDATA[<pre><code>sudo apt install ros-kinetic- //用于安装ros中的依赖项</code></pre><p>samba服务器客户端</p><pre><code>sudo apt install smbclientsudo apt-get install cifs-utils   #下载相应组件sudo mount -t cifs //10.1.1.20/share  /home/xx/share  #挂载服务器//10.1.1.20/share    /home/xx/share cifs passward=123,dir_mode=0777,file_mode=0777 0 0  #ubuntu16开机自动挂载</code></pre><p>  在catch_bottle.launch里面，点击ur5e_ros_control.launch，ctrl+b进入文件，修改robot_ip为对应的虚拟机里面的IP地址。<br>  修改虚拟机ip的方法<br>  sudo ifconfig eth0 10.1.1.190</p><p>ctrl+h为显示隐藏文件,再点一次为隐藏</p><pre><code>sudo gedit /etc/hosts  //为Ubuntu 16.04 修改hosts的命令，例：添加一行  10.1.1.20  server-power//实验室服务器sudo apt-get --purge remove+包名  //卸载软件dpkg --list //可以查看安装的所有的软件，并且是按首字母排序sudo apt-get -f install //能装好大部分的依赖；sudo apt-get install+依赖名  //可以安装指定的依赖项sudo chmod 777+文件的完整路径     //可修改文件权限为可写sudo rm -rf+文件名 //暴力删除文件wine uninstaller //卸载用wine安装的软件</code></pre><p>c++中在全局声明中使用 using namespace std,表示使std命名空间中的名称全局可用。类似的有using std::cout，使标准库中的cout在指定区域内可用。</p><pre><code>wine CAJVieweru.exe  #打开知网阅读器,需要在软件安装目录下，wine为Ubuntu运行Windows程序的工具。sudo mount -t cifs //10.1.1.20/share  /home/xx/share  #挂载服务器 </code></pre><p>不能用“PATH=/some /directory”，因为这将删除 $PATH 中其他的所有目录，只能作添加：“PATH=$PATH:/some/directory”。</p><p>  clion使用技巧，如果发现添加了新的项目，编译找不到相关节点， 首先在clion里查看环境配置，看是否配置了有关路径。之外可以删除cmake-build-debug文件，用rebuild project重新生成，再编译运行。<br>  如果该项目之前放在其他位置运行过，最好完全删除之前的，避免相互影响。  </p><h2 id="leap-motion"><a href="#leap-motion" class="headerlink" title="leap motion"></a>leap motion</h2><pre><code>sudo leapd #运行leapdLeapControlPanel #打开控制面板 或者用命令LeapControlPanel --showsettingsVisualizer #可视化</code></pre><h2 id="单目摄像头与双目摄像头在测距上的差异"><a href="#单目摄像头与双目摄像头在测距上的差异" class="headerlink" title="单目摄像头与双目摄像头在测距上的差异"></a>单目摄像头与双目摄像头在测距上的差异</h2><p>   单目摄像头的大致测距原理，是先通过图像匹配进行目标识别（各种车型、行人、物体等），再通过目标在图像中的大小去估算目标距离。这就要求在估算距离之前首先对目标进行准确识别，是汽车还是行人，是货车、SUV还是小轿车。准确识别是准确估算距离的第一步。<br>   而双目检测的方式就是通过对两幅图像视差的计算，直接对前方景物（图像所拍摄到的范围）进行距离测量，而无需判断前方出现的是什么类型的障碍物。所以对于任何类型的障碍物，都能根据距离信息的变化，进行必要的预警或制动。<br>    #引用自<a href="http://www.eepw.com.cn/article/201710/367600.htm" target="_blank" rel="noopener">http://www.eepw.com.cn/article/201710/367600.htm</a></p><pre><code>roslaunch gazebo_ros empty_world.launch #开启gazeborm test.txt #删除test文件rm -r test #删除非空文件夹及其目录下的所有文件夹及文件rmdir test #删除空文件夹killall gzserverkillall gzclient</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
